<!DOCTYPE html><html lang="en"><head><meta charset="utf-8" /><title>Cloud Workflow Language</title><meta content="RightScale's server orchestration solution allows managing entire applications running on the cloud by leveraging the RightScale platform." name="description" /><meta content="initial-scale=1" name="viewport" /><meta content="1" name="docsearch:version_major" /><link href="https://my.rightscale.com/favicon.ico" rel="icon" /><!--Stylesheets--><link href="../../../../css/main.css" rel="stylesheet" /><!--JavaScript--><script src="../../../../js/main.js"></script></head><body class="ss ss_reference ss_reference_rcl ss_reference_rcl_v1 ss_reference_rcl_v1_index" data-spy="scroll" data-target="#subnav-right"><nav class="navbar navbar-default navbar-fixed-top" role="navigation"><div class="container-fluid max-width"><div class="navbar-header"><button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse" type="button"><span class="sr-only">Toggle navigation</span><span class="icon-bar"></span><span class="icon-bar"></span><span class="icon-bar"></span></button><a class="navbar-brand" href="/"><img src="../../../../img/FX_Logo_pos.png" /></a></div><div class="navbar-collapse collapse"><ul class="nav navbar-nav navbar-right"><li><a target="_blank" href="https://community.flexera.com/t5/Flexera-Community/ct-p/Flexera_Community">Community</a></li><li><a target="_blank" href="https://www.flexera.com/blog/">Blog</a></li><li><a target="_blank" href="https://www.flexera.com/about-us/contact-us.html">Contact</a></li><li><a target="_blank" href="https://login.rightscale.com/login/session/new">Log In</a></li></ul><ul class="nav navbar-nav navbar-right nav-status"><li class="nav-al-search"><a href="../../../../search.html">Search</a></li></ul><form class="navbar-form navbar-left" role="search" action="/search.html" method="get" ><div class="form-group"><input class="form-control input-sm" id="site-search" placeholder="Search" type="text" name="q" /></div><input type="submit" style="position: absolute; left: -9999px"/></form><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/2/docsearch.min.js"></script><script type="text/javascript"> docsearch({apiKey: 'b58c3ad6ab9d6e3cd425867d64a6766f',indexName: 'rightscale',inputSelector: '#site-search', debug: false, autocompleteOptions: {autoselect: false}});</script></div></div></nav><div class="wrap"><div class="container-fluid max-width"><div class="row"><div class="col-sm-3"><div class="clearfix"><aside class="main-nav" role="complementary"><nav class="list-group" role="navigations"><a class="list-group-item" href="/ss/"><h4 class="list-group-heading"><img src="../../../../img/product-self-service.svg" /><span>Self-Service</span></h4></a><a class="list-group-item" href="../../../about.html">About</a><a class="list-group-item" href="/ss/getting_started">Getting Started</a><a class="list-group-item" href="/ss/guides">Guides</a><a class="list-group-item" href="/ss/reference">Reference</a><a class="list-group-item" href="/ss/tools">Tools</a></nav></aside><div class="callout"><a href="/api/"><div class="panel panel-default"><div class="panel-body"><div class="callout-title"><img src="../../../../img/icon-api.svg" /><h4>Flexera CMP APIs</h4></div><span>See the API reference documentation for all of our products.</span></div></div></a></div><div class="callout"><a href="../../../../ca/cloud_comp/ca_getting_started_with_cloud_comparison.html"><div class="panel panel-default"><div class="panel-body"><div class="callout-title"><img src="../../../../img/icon-cloud-blue.svg" /><h4>Cloud Comparison</h4></div><span>Compare public clouds based on the features they offer.</span></div></div></a></div><div class="callout"><a target="_blank" href="http://feedback.rightscale.com"><div class="panel panel-default"><div class="panel-body"><div class="callout-title"><img src="../../../../img/icon-feedback.svg" /><h4>Feedback</h4></div><span>Get in touch and we’ll get back to you as soon as we can.</span></div></div></a></div><div class="callout"><a href="/release-notes"><div class="panel panel-default"><div class="panel-body"><div class="callout-title"><img src="../../../../img/icon-notes.svg" /><h4>Release Notes</h4></div><span>See the notes for the latest releases of each application and what’s changed.</span></div></div></a></div></div></div><div class="col-sm-9"><div class="row"><div class="col-sm-9"><div class="clearfix"><p><a href="../../../../">Flexera CMP Docs</a> &#x2F; <a href="../../../">Self-Service Docs</a> &#x2F; <a href="../../">Reference</a> &#x2F; <a href="../">RightScale Cloud Workflow</a></p><div class="pull-right"><div class="btn-group"><a aria-haspopup="true" class="btn btn-success dropdown-toggle" data-toggle="dropdown" id="version-dropdown" type="button"><strong>Version:</strong>&nbsp;<span>1&nbsp;</span><span class="caret"></span></a><ul class="dropdown-menu" role="menu"><li><a href="/ss/reference/rcl/v1/index.html">1</a></li><li><a href="/ss/reference/rcl/v2/index.html">2</a></li></ul></div></div><div class="page-header"><h1>Cloud Workflow Language</h1></div><div class="main-content"><h2 id="overview">Overview</h2>

<p>RightScale&#39;s cloud orchestration solution allows managing entire applications running on the cloud by leveraging the RightScale platform. The orchestration may include activities like configuring and launching servers in order, running operational runlists, scaling server arrays, sending emails, retrieving and analyzing metrics data, sending requests to external applications, prompting users for input, etc.</p>

<ul>
<li><p>A <em>cloud workflow</em> is the static definition of all activities involved in a given orchestration instance. At any point in time a single cloud workflow may have multiple instances running. Such instances are called processes. Each process is launched with (and maintains) its own state.</p></li>
<li><p>A cloud workflow may make calls into other cloud workflows and thus the set of activities that ends up running in a single process may span multiple cloud workflows.</p></li>
<li><p>A cloud workflow is thus akin to the source code of a program while a process is similar to the execution of that program.</p></li>
</ul>

<h2 id="rcl">RCL</h2>

<p>Cloud workflows are written in a language called <strong>RCL</strong>, an acronym for RightScale Cloud Workflow Language. <strong>Why a new language?</strong> The short answer is that the runtime characteristics of a process are fundamentally different from a typical program execution. Processes tend to execute over long periods of time in an event driven manner, much of the time the process sleeps waiting for the next event to occur at which point it wakes up, makes some decisions and kicks off new actions, and goes to sleep again. Each time it wakes up, the process can be executed by a different server such that changes in load, platform reconfigurations, and machine failures don&#39;t affect process execution. Cloud workflows are also often parallel; an event may kick off parallel actions. Sometimes several parallel strategies are initiated and the first one to succeed is pursued while others are aborted. Workflow languages such as RCL are designed to support these characteristics natively, thereby simplifying the writing of robust and powerful workflows. However, an important design criteria is to make it as similar to regular scripting languages as possible to make it intuitive even for users not usually exposed to authoring workflows. The hope is to create a language that is easy to pick up and consistent but also exposes all the basic constructs that are needed to build powerful workflows.</p>

<p>At the core RCL allows writing a sequence of expressions. Such expressions may describe the control flow of a process or may specify actions that need to be taken on resources. A cloud workflow is thus a sequence of expressions executed sequentially (which is not saying that all activities must be executed sequentially; for example, the <code>concurrent</code> expression allows for running activities concurrently).</p>

<p>Before going further into the details of the language, here is an example of a complete cloud workflow that can be used to launch servers in order (database first, then application servers). This cloud workflow uses an application name given as an input to find the database servers by name and to build a tag used to retrieve the app servers.</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">launch_app</span><span class="p">(</span><span class="vg">$app</span><span class="p">)</span>
  <span class="n">concurrent</span> <span class="ss">timeout: </span><span class="mi">30</span><span class="n">m</span> <span class="k">do</span> <span class="c1"># Launch database master and slave concurrently and wait for up to 30 minutes</span>
    <span class="nb">sub</span> <span class="k">do</span> <span class="c1"># Launch database master</span>
      <span class="vi">@db_master</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name=="</span> <span class="o">+</span> <span class="vg">$app</span> <span class="o">+</span> <span class="s2">"_db_master"</span><span class="p">])</span> <span class="c1"># Get server using its name</span>
      <span class="n">assert</span> <span class="n">size</span><span class="p">(</span><span class="vi">@db_master</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># Make sure there is one and only one server with that name</span>
      <span class="vi">@db_master</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># Launch server</span>
      <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@db_master</span><span class="ss">:state</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span> <span class="c1"># Wait for it to become operational</span>
    <span class="k">end</span>
    <span class="nb">sub</span> <span class="k">do</span> <span class="c1"># Launch database slave</span>
      <span class="vi">@db_slave</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name=="</span> <span class="o">+</span> <span class="vg">$app</span> <span class="o">+</span> <span class="s2">"_db_slave"</span><span class="p">])</span>
      <span class="n">assert</span> <span class="n">size</span><span class="p">(</span><span class="vi">@db_slave</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
      <span class="vi">@db_slave</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
      <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@db_slave</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span>
      <span class="vc">@@slave</span> <span class="o">=</span> <span class="vi">@db_slave</span> <span class="c1"># Save reference to slave in global variable so it can be used later</span>
    <span class="k">end</span>
  <span class="k">end</span>

  <span class="c1"># This won't execute until both servers are operational</span>
  <span class="vc">@@slave</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"db::do_init_slave"</span><span class="p">)</span> <span class="c1"># Init the slave</span>
  <span class="vi">@apps</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name=="</span> <span class="o">+</span> <span class="vg">$app</span> <span class="o">+</span> <span class="s2">"_appserver"</span><span class="p">])</span> <span class="c1"># find the app servers</span>
  <span class="vi">@apps</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># ...and launch them</span>

<span class="k">end</span>
</code></pre>

<p>The code should be fairly self-explanatory, a few hints that may help:</p>

<ul>
<li>Variables whose names start with a <code>$</code> symbol contain JSON values (strings, numbers, booleans etc) while variables whose names start with a <code>@</code> symbol contain collections of resources (deployments, servers, instances etc.). Variables that contain collection of resources are referred to references to differentiate them from variables which contain JSON values. The language also supports global variables prefixed with <code>$$</code> and global references prefixed with <code>@@</code> whose values are accessible to the entire process definition and do not follow the usual scoping rules.</li>
<li>Resources have actions and fields that can be called with the <code>.</code> operator (e.g. <code>@db_server.launch()</code>, <code>@db_master.state</code>). Actions take parenthesis while fields do not.</li>
<li>Code written in RCL always deals with <em>collections</em> of resources and never with a single resource. This explains why <code>@apps.launch()</code> ends up launching all the application servers.</li>
</ul>

<p>Resource actions (<code>launch()</code> and <code>run_executable()</code> in the definition above) are a special kind of expression that allows interacting with external systems such as the RightScale platform. A resource encapsulates external state and its actions allow managing that state. The state is made available through <em>fields</em> (e.g. <code>state</code> in the definition above). This is similar in nature to objects (resources), methods (actions) and members (fields) in an object oriented language with the distinction that fields are read-only and can only be updated through actions.</p>

<p>Resources can be located using the resource type <em>actions</em> (<code>get()</code> in the definition above).</p>

<p><em>Functions</em> are built-in helpers that provide logic that gets run in the engine itself (<code>size()</code>, <code>sleep_until()</code>) in the definition above).</p>

<p>Finally, expressions can also be adorned with <em>attributes</em>, which allow for attaching additional behavior to the execution of the expression (such as error handling, timeout etc.). In the definition above the <code>timeout</code> attribute is used to guarantee that the process will not wait for more than 30 minutes for both database servers to become operational.</p>

<p>Put together, resource actions, resource fields, resource type actions, functions and attributes make up the bulk of the language.</p>

<h2 id="resources">Resources</h2>

<p>Resources present the author with a consistent toolset for managing external state. Through resources one can enumerate collections, locate items and act on them. For example, resources allow managing RightScale abstractions like <em>deployments</em>, <em>servers</em>, <em>server arrays</em>, <em>instances</em>, etc. Each resource corresponds to an underlying abstraction and is scoped to a <em>namespace</em>. For example, a RightScale Server resource might have:</p>

<ul>
<li><strong>namespace:</strong> <em>rs</em></li>
<li><strong>type:</strong> <em>servers</em></li>
<li><strong>href:</strong> <em>servers/123</em></li>
<li><strong>fields:</strong> <em>cloud: aws-us-east, datacenter: us-east-1a, launchedat: 2011/8/1 16:56:87, ...</em></li>
<li><strong>links:</strong> <em>current_instance, deployment, ...</em></li>
<li><strong>actions:</strong> <em>launch(), terminate(), clone(), ...</em></li>
<li><strong>type actions:</strong> <em>get(), create()</em></li>
</ul>

<p><strong>Note:</strong> <em>The resource type name (<q>servers</q>) is plural.</em></p>

<p>The following sections further discuss the various resource properties that are listed above (<code>href</code>, <code>fields</code>, <code>links</code>, etc.).</p>

<h3 id="resources-namespaces">Namespaces</h3>

<p>Resources are exposed to the cloud workflow engine in the form of HTTP APIs. A namespace exposes a given API to cloud workflows. The <code>rs</code> namespace encapsulates RightScale Cloud Management API 1.5 and gives access to all the resources it defines. It also implicitly scopes that access to the account running the process.</p>

<p>The rest of this document describes how to work with resources in a cloud workflow. Resources are managed in collections and expose fields, links, and actions. The <a href="#mapping-resources-to-the-rightscale-apis">Mapping RightScale Resources to the APIs</a> section may help make things more concrete as it lays out how the various constructs map back to the RightScale API in the rs namespace.</p>

<h3 id="resources-resource-collections">Resource Collections</h3>

<p>An important aspect of the language that may not be intuitive is that a cloud workflow always acts on a <em>collection</em> of resources. The resources in a collection are always of the <em>same type</em> (such as all servers or all instances). For example, executing resource actions is always done on a collection:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre>

<p>The expression above will execute the action <code>launch()</code> on all the resources in the <code>@servers</code> resource collection. <a href="#resource-actions">Resource actions</a> are further described below.</p>

<p>A quick example of Server Array can also be seen below, specific to a multi_update_inputs action.</p>

<p><code>@server_array.multi_update_inputs({ &quot;inputs&quot; =&gt; { &quot;INPUT1&quot; =&gt; &quot;text:foo&quot;, &quot;INPUT2&quot; =&gt; &quot;text:bar&quot; } })</code></p>

<p><em>Or</em></p>

<p><code>@server_array.multi_update_inputs(inputs: { &quot;INPUT1&quot;: &quot;text:foo&quot;, &quot;INPUT2&quot;: &quot;text:bar&quot; } })</code></p>

<p>RCL includes built-in functions to manipulate collections. Functions like <code>first()</code>, <code>last()</code>, etc. also always return collections of resources (albeit made of a single resource in both these cases). Always working with collections allows for a much simpler language that does not need to differentiate between managing collections or unique items. The language supports constructs for checking the size of a collection and for extracting items (creating another collection with the extracted items). A collection may contain any number of resources, including no resource. Executing an action on an empty resource collection is not an error, it just has no effect.</p>

<p><strong>Note:</strong> <em>An empty resource collection still has an associated resource type, attempting to execute an action not supported by the resource type on an empty collection raises an error.</em></p>

<h4 id="references">References</h4>

<p>Resource collections can be stored into <em>references</em>, like <code>@servers</code> in the example above. A reference name must start with <code>@</code> and may contain letters, numbers, and underscores. The convention used for reference names consists of using <em>lower_case</em> although all that really matters to the engine is that the first character be <code>@</code>. A reference can be initialized using the results of an action or using one of the operators described in <a href="ss_RCL_operators.html#collection-and-array-operator">Resource Collection Management</a> section in the <a href="ss_RCL_operators.html">RCL Operators</a> document.</p>

<p><strong>Note:</strong> <em>References must be initialized before they can be used in expressions. Using an uninitialized reference in an expression results in a runtime error. References can be initialized to an empty collection using the resource types <code>empty()</code> action described below as in: <code>@servers = rs.servers.empty()</code>.</em></p>

<h3 id="resources-resource-fields">Resource Fields</h3>

<p>A cloud workflow primarily orchestrates how state propagates through various resources. Computation done on that state should be done primarily by systems exposing these resources (e.g. RightScale&#39;s APIs). Sometimes though it can be useful for a cloud workflow to read the value of a given resource field so it can trigger the proper activities. Fields can be read as follows:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span>   <span class="c1"># Retrieve name of first server in collection</span>
<span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span><span class="p">[]</span> <span class="c1"># Retrieve names of all servers in collection</span>
</code></pre>

<p>The first line returns a string while the second line returns an array of strings, each element corresponding to the name of the resource in the <code>@servers</code> collection at the same index.</p>

<p><strong>Note:</strong> <em>Resource references always contain a collection of resources and extracting a field, like in the expression <code>@servers.name[]</code>, always returns an array, even if the collection consists of only one server. The notation sans brackets is meant to help in the case a collection only contains one element.</em></p>

<h4 id="field-values">Field Values</h4>

<p>Fields contain JSON values:</p>

<ul>
<li><strong>Strings(UTF-8 encoded):</strong> <q>a string</q>, escape <q>with \ as in</q>\&quot;&quot;</li>
<li><strong>Numbers:</strong> 1, 1.2, 3e10, -4E-100</li>
<li><strong>Booleans:</strong> true, false</li>
<li><strong>Null:</strong> null</li>
<li><strong>Arrays:</strong> [ <q>a</q>, 1 ]</li>
<li><strong>Ranges:</strong> [1..3], [<q>aa</q>..<q>zz</q>], [<q>server-1</q>..<q>server-3</q>], [$start..$finish]</li>
<li><strong>Hashes:</strong> { <q>key</q>: <q>value</q>, <q>key2</q>: 42, <q>key3</q>: true }</li>
<li><strong>Datetime:</strong> d<q>2012/07/01</q>, d<q>2012/07/12 04:21:14 PM</q></li>
</ul>

<p>Elements of arrays and hashes can be retrieved using the square bracket <code>[ ]</code> operator. For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span><span class="p">[][</span><span class="mi">0</span><span class="p">]</span>
</code></pre>

<p>The snippet above returns a string containing the name of the first resource in the collection, it does the same as <code>@servers.name</code>. Fields are read-only and can only be modified by calling actions on the underlying resource.</p>

<p>Fields can also have datetime values and, for this purpose, the JSON syntax is extended to support datetime values as follows:</p>

<p><code>d&quot;year/month/day [hours:minutes:seconds] [AM|PM]</code></p>

<p><strong>Note:</strong> <em>Date time values are always UTC.</em></p>

<p>Examples are:</p>

<p><code>d&quot;2012/07/01&quot;d&quot;2012/07/12 04:21:14 PM&quot;</code></p>

<p>If no time is specified then midnight is used (00:00:00). If no AM/PM value is specified then AM is assumed unless the hour value is greater than 12.</p>

<p>Range in RCL has a start and finish values separated by <code>..</code>. These start/finish values can either be numbers or strings but both start and finish should be of the same type. For example, <code>[&quot;a&quot;..3]</code> will cause an error.</p>

<h3 id="resources-resource-links">Resource Links</h3>

<p>Resources also contain links that point to other collections. The main difference with respect to fields is that links yield resource collections rather than JSON values. For example, the RightScale <code>deployments</code> resource type has a link named <code>servers</code> that represents the collection of all servers in a deployment.</p>

<p>Retrieving the link on a collection will <q>flatten</q> the result. For example, if deployment <em>A</em> contains server <em>S1</em> and <em>S2</em> and deployment <em>B</em> contains server <em>S3</em> accessing the link servers on a collection made of these two deployments will yield a collection composed of <em>S1</em>, <em>S2</em>, and <em>S3</em>.</p>

<p>Links on resource collections can be followed using the following syntax:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="vi">@deployments</span><span class="p">.</span><span class="nf">servers</span><span class="p">()</span>
</code></pre>

<p>The snippet above assumes that the <code>@deployments</code> reference contains a resource collection made of deployments.</p>

<p>Links may take arguments depending on the resource type and the nature of the link. Some links may return a single resource while others may return multiple resources. In both these cases arguments may be used to further specify what should be returned. Some arguments control which resource fields in the results should be initialized (<em>views</em>) while others affect what resources should be returned (<em>filters</em>). For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="vi">@deployments</span><span class="p">.</span><span class="nf">servers</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"state==operational"</span><span class="p">])</span>
</code></pre>

<p>The example above only returns the operational servers in the given deployments. As with resource fields and actions, the complete list of available links and their arguments is documented in the <a href="/api/">CM API 1.5 reference</a>.</p>

<h3 id="resources-provisioning-and-terminating-resources">Provisioning and Terminating Resources</h3>

<p>At the end of the day Cloud Workflow is all about managing resources. The most common activities executed by workflows consist of creating and deleting resources. Often times just creating the resource is not enough; for example just creating a RightScale server through the RightScale API is not that useful, instead it would be much more useful if a single operation could create the server, launch it and wait until it is operational. This is the intent behind the built-in <code>provision()</code> function. This function behaves differently depending on the resource being provisioned. The exact behavior for each RightScale resource is described in the <a href="ss_RCL_functions.html#resource-management">Functions section</a>.</p>

<p>Similarly, just deleting a RightScale server is not that useful; instead the <code>delete()</code> function terminates the server, waits until it is terminated and then deletes it.</p>

<p>In both cases (<code>provision()</code> and <code>delete()</code>) the intent is for the function to act atomically. In particular the <code>provision()</code> function will clean up if anything fails after the resource has been created. For example, if the server fails to go to operational (strands in RightScale) then it is terminated and deleted automatically. If you need more control on how the resource is created or how failure is handled then use the <code>create()</code> and <code>destroy()</code> actions described in the <a href="#built-in-actions">Built-in Actions</a> section below, these are a subset of the actions used internally by <code>provision()</code> and <code>delete()</code>.</p>

<h3 id="resources-resource-declarations">Resource Declarations</h3>

<p>So far we have discussed how it is possible to manage resource collections in RCL. Resource collections point to existing resources in the cloud. By definition the <code>provision()</code> function cannot take a resource collection as argument but needs a description of what the resource ought to be instead. This description is called a <em>resource declaration</em>. It consists of a JSON object which defines the resource <code>namespace</code>, <code>type</code>, and <code>fields</code>. The field values must be JSON encoded, in particular this means that values that are strings must start and end with double quotes. The following example creates a RightScale deployment using the <code>provision()</code> function:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># Create the new deployment declaration, note that the value</span>
<span class="c1"># gets assigned to a variable whose name starts with a "@"</span>
<span class="c1"># Also note that "fields" values must be JSON encoded</span>
<span class="vi">@new_deployment</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
                    <span class="s2">"type"</span><span class="p">:</span>      <span class="s2">"deployments"</span><span class="p">,</span>
                    <span class="s2">"fields"</span><span class="p">:</span>    <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_deployment"</span> <span class="p">}</span> <span class="p">}</span>

<span class="c1"># Now provision deployment</span>
<span class="n">provision</span><span class="p">(</span><span class="vi">@new_deployment</span><span class="p">)</span>

<span class="c1"># @new_deployment now contains a resource collection and can be</span>
<span class="c1"># used to execute actions (see Resource Actions below)</span>
<span class="vi">@new_deployment</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="s2">"deployment"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"new_name"</span> <span class="p">})</span>
</code></pre>

<p>Upon success the <code>provision()</code> function transforms the declaration given as parameter into a collection.</p>

<p>The JSON object that backs a declaration can be retrieved from a declaration using the <code>to_object()</code> function. In particular this makes it possible to manipulate declarations given to a definition prior to calling the <code>provision()</code> function.</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># The definition below takes a declaration as parameter</span>
<span class="n">define</span> <span class="n">create_deployment</span><span class="p">(</span><span class="vi">@deployment</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># Retrieve JSON object backing declaration</span>
  <span class="vg">$json</span> <span class="o">=</span> <span class="n">to_object</span><span class="p">(</span><span class="vi">@deployment</span><span class="p">)</span>
  <span class="c1"># Manipulate JSON directly to change declaration</span>
  <span class="vg">$json</span><span class="p">[</span><span class="s2">"fields"</span><span class="p">][</span><span class="s2">"name"</span><span class="p">]</span> <span class="o">=</span> <span class="s2">"some_other_name"</span>
  <span class="c1"># Assign the JSON objet back to a declaration</span>
  <span class="vi">@new_deployment</span> <span class="o">=</span> <span class="vg">$json</span>
  <span class="c1"># Now provision deployment</span>
  <span class="n">provision</span><span class="p">(</span><span class="vi">@new_deployment</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>The declaration field values are always strings. The strings may contain literal JSON values like in the example above but may also contain RCL expressions. The expressions get parsed and executed when the declaration is provisioned via the <code>provision()</code> function, when <code>to_object()</code> is called on it or when a field is accessed (for example <code>@deployment.name</code>). This makes it possible to initialize a process with declarations whose fields contain RCL snippets that get parsed and executed when the process starts. For example, such fields may use the <code>find()</code> function to find dependent resources dynamically (a server image or instance type, a security group network, etc.). The execution of a field can be delayed until the actual provision happens by marking the field as an unresolved field.</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@security_group</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
                    <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"security_groups"</span><span class="p">,</span>
                    <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_security_group"</span> <span class="p">}</span> <span class="p">}</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"servers"</span><span class="p">,</span>
            <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_server"</span><span class="p">,</span>
                        <span class="s2">"security_group_hrefs"</span><span class="p">:</span> <span class="p">[</span><span class="vi">@security_group</span><span class="p">]</span> <span class="p">}</span> <span class="p">}</span>
</code></pre>

<p>In the example above, the reference <code>@security_group</code> is evaluated when the assignment statement is processed. Add the security group reference to the unresolved fields array to delay its evaluation until the declaration is provisioned (for example if the security group needs to provisioned first):</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@security_group</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
                    <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"security_groups"</span><span class="p">,</span>
                    <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_security_group"</span> <span class="p">}</span> <span class="p">}</span>

<span class="vi">@server</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"servers"</span><span class="p">,</span>
            <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_server"</span><span class="p">,</span>
                        <span class="s2">"security_group_hrefs"</span><span class="p">:</span> <span class="s2">"[@security_group]"</span> <span class="p">},</span>
            <span class="s2">"unresolved_fields"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"security_group_hrefs"</span><span class="p">]</span> <span class="p">}</span>
</code></pre>

<p>Fields holding direct references to resources collections such as <code>@security_group</code> get substituted with the value of the <code>href</code> field of the first element in the corresponding resource collection. For example <code>&quot;[@security_group]&quot;</code> will be evaluated to <code>[&quot;/api/security_groups/ABDC123&quot;]</code>.</p>

<h3 id="resources-provisioning-dependencies">Provisioning Dependencies</h3>

<p>A resource declaration can have dependencies that need to provisioned before the original declaration. Dependencies can be specified in two forms: explicit (specified using the <code>dependencies</code> field of a declaration) or implicit (one of the declaration field referring to another declaration). In the example in the section above the <code>@security_group</code> collection is an implicit dependency of the server therefore provisioning the server first provisions the security group (if it isn&#39;t provisioned already). The <code>provision()</code> function is idempotent so if the argument is already provisioned, it will simply return the argument. Dependencies can also be specified explicitly:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@master</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
            <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"servers"</span><span class="p">,</span>
            <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"master server"</span> <span class="p">}</span> <span class="p">}</span>

<span class="vi">@slave</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span>
           <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"servers"</span><span class="p">,</span>
           <span class="s2">"fields"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"slave server"</span> <span class="p">},</span>
           <span class="s2">"dependencies"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"@master"</span><span class="p">]</span> <span class="p">}</span> <span class="c1"># Master server should be provisioned before slave</span>
</code></pre>

<p>A declaration provisioned as a dependency of another declaration causes that declaration to be added as a <em>dependent</em> of that dependency. In the example above <code>@server</code> is added as a dependent of the <code>@security_group</code>.</p>

<h3 id="resources-deleting-dependents">Deleting Dependents</h3>

<p>Since <code>provision()</code> keeps track of dependents as the dependencies are provisioned, the <code>delete()</code> function can delete the dependents before deleting the collection. Simply destroying the security group before destroying the server would fail because the server is still using it. However thanks to the built-in dependency tracking described above <code>delete(@security_group)</code> first deletes the server.</p>

<p>The dependents of a collection are kept in the collection itself along with other properties of a collection. So doing the following causes an error as the code initializes the security group collection using a <code>find</code> which does not know about the dependent.</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">delete_security_group</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@security_group</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="s2">"security_groups"</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"my_security_group"</span> <span class="p">})</span>
  <span class="n">delete</span><span class="p">(</span><span class="vi">@security_group</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>The security_group is a newly created collection and doesn&#39;t have any information about its dependents so deleting it will not delete the server.</p>

<h3 id="resources-resource-actions">Resource Actions</h3>

<p>Resource actions allow a cloud workflow to act on resources: scripts can be run on running servers, instances can be rebooted etc. Actions may accept zero or more argument(s). For example, the <code>terminate()</code> action takes no argument, the <code>run_executable()</code> action requires an executable name and inputs, etc.</p>

<p>Argument values are written using the JSON syntax already covered in the <a href="#resource-fields">Resource Fields</a> section above and all arguments are specified by name. For example, the <code>run_executable()</code> action requires two arguments: <code>recipe_name</code> is the name of the recipe to run, and <code>inputs</code> is the list of inputs to be used for the recipe execution. The following two expressions are equivalent invocations of <code>run_executable()</code>:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># Argument names must be explicitly given</span>
<span class="vi">@instances</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"lb::setup_lb"</span><span class="p">,</span> <span class="ss">inputs: </span><span class="p">{</span> <span class="s2">"lb/applistener_name"</span><span class="p">:</span> <span class="s2">"text:my_app"</span> <span class="p">})</span>

<span class="c1"># But order does not matter</span>
<span class="vi">@instances</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">inputs: </span><span class="p">{</span> <span class="s2">"lb/applistener_name"</span><span class="p">:</span> <span class="s2">"text:my_app"</span> <span class="p">},</span> <span class="ss">recipe_name: </span><span class="s2">"lb::setup_lb"</span><span class="p">)</span>
</code></pre>

<p>As a convenience, it is also possible to pass multiple arguments as a single hash value where each key corresponds to the argument name and each value to the corresponding argument value. So the request to execute the <code>run_executable()</code> action above is also equivalent to:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># Arguments can be given as a single hash value</span>
<span class="vi">@instances</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">({</span> <span class="s2">"recipe_name"</span><span class="p">:</span> <span class="s2">"lb::setup_lb"</span><span class="p">,</span> <span class="s2">"inputs"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"lb/applistener_name"</span><span class="p">:</span> <span class="s2">"text:my_app"</span> <span class="p">}</span> <span class="p">})</span>
</code></pre>

<p>This makes it convenient to call actions passing in variables that were retrieved programmatically.</p>

<h3 id="resources-built-in-actions">Built-in Actions</h3>

<p>All resource collections expose the following actions on top of the actions supported by the resource type:</p>

<ul>
<li><strong>get():</strong> Refresh resource fields</li>
<li><strong>update():</strong> updates fields of the underlying resources as supported by the resource type</li>
<li><strong>destroy():</strong> destroys all resources in the collection</li>
</ul>

<h4 id="get()">get()</h4>

<p>The <code>get()</code> action re-fetches the resource and updates the fields with the results. This is useful when waiting on a resource to be in a certain state for example and is used internally by the <code>sleep_until</code> function.</p>

<h4 id="update()">update()</h4>

<p>The <code>update()</code> action is used to update resource fields. The set of supported fields is specified by the resource type. For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@deployment</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="ss">deployment: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"A new name"</span> <span class="p">})</span>
</code></pre>

<p>The snippet above updates the name of all deployments in <code>@deployment</code> to <q>A new name</q>.</p>

<p>The exact set of arguments is dependent on the resource type. The convention used by RightScale resources is to use a hash object whose name is the singular resource type name, the keys are the field names and the values are the new values.</p>

<p><strong>Note:</strong> <em>Some resource types do not support updating fields and the <code>update()</code> action will fail when called on a collection of that type.</em></p>

<h4 id="destroy()">destroy()</h4>

<p>The <code>destroy()</code> action destroys all resources in the collection. This action does not take any argument. Note that contrary to the built-in <code>delete()</code> function the <code>destroy()</code> action results in a single API call (per resource in the collection) to destroy the resource (i.e. a DELETE API call). There&#39;s no built-in logic around waiting for a server to be terminated, etc.</p>

<p><strong>Note:</strong> <em>Some resource types do not support deleting resources and hence the <code>destroy()</code> action will fail when called on a collection of that type.</em></p>

<h3 id="resources-resource-type-actions">Resource Type Actions</h3>

<p>So far we have seen the various ways that a cloud workflow may interact with resource collections:</p>

<ul>
<li>Actions may be called on collections using <code>action_name(argument: &quot;argument_value&quot;, ...)</code></li>
<li>Fields may be retrieved using <code>:field_name</code></li>
<li>Links may be followed using <code>link_name(argument: &quot;argument_value&quot;, ...)</code></li>
</ul>

<p>Cloud workflows may also interact with resource types to locate resources, create new resources, and execute actions that apply to a resource type rather than specific resources. For example, the RightScale <em>instances</em> resource type exposes actions to terminate or run scripts on multiple instances at once. The syntax to designate a resource type is:</p>

<p><code>&lt;namespace&gt;.&lt;resource type&gt;</code></p>

<p>For example:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/clouds/1234"</span><span class="p">).</span><span class="nf">instances</span><span class="p">()</span>
</code></pre>

<p>The expression above designate the <code>instances</code> resource type of the <em>rs namespace</em>. Resource types support the following built-in actions:</p>

<ul>
<li><strong>get()</strong> is the resource type action used to locate resources. See Locating Resources below.</li>
<li><strong>create()</strong> is used to create new resources.</li>
<li><strong>empty()</strong> returns an empty resource collection of the given resource type.</li>
<li><strong>request()</strong> is used to call a custom action whose name is <em>get</em>, <em>create</em>, <em>empty</em>, or <em>request</em>. The first argument is the name of the action and the following arguments match the arguments expected by the custom action. This action is merely to work around name clashes where a resource type would expose an action that has the same name as one of the built-in actions.</li>
</ul>

<p><strong>Note:</strong> <em>There is no resource type custom action in the rs namespace named <code>get</code>, <code>create</code>, <code>empty</code> or <code>request</code> and <code>request</code> is thus never needed for resource types in that namespace.</em></p>

<p>Resource types may expose custom actions on top of these built-in actions. For example, running a recipe on multiple instances can be done using:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/clouds/1234"</span><span class="p">).</span><span class="nf">instances</span><span class="p">().</span><span class="nf">multi_run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"lb::setup_load_balancer"</span><span class="p">,</span> <span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==front_end"</span><span class="p">])</span>
</code></pre>

<p>While using <code>multi_run_executable()</code> is functionally equivalent to using something like <code>@instances.run_executable()</code>, where <code>@instances</code> was initialized with the same set of resources, the two expressions are executed differently by the engine. In the former case, the engine makes a single call to the RightScale API which dispatches the script or recipe on all instances concurrently. In the latter case, the engine iterates through all the instances in the collection and makes one API call for each to dispatch the script or recipe.</p>

<p>The <a href="#mapping-resources-to-the-rightscale-apis">Mapping RightScale Resources to the APIs</a> section describes how to find the available RightScale resource type actions and arguments using the RightScale API documentation.</p>

<h3 id="resources-creating-resources">Creating Resources</h3>

<p>The <code>create()</code> resource type action allows creating new resources. For example, creating a new RightScale deployment can be done with:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">deployment: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"New deployment"</span> <span class="p">})</span>
</code></pre>

<p>The arguments used by the <code>create()</code> action are resource type specific. The convention used by RightScale resources is to use a single hash argument whose name is the singular resource type name, the keys of the hash are the field names and the values are the field values. Note that contrary to the <code>provision()</code> function the <code>create()</code> action makes a single API call to create the resource (i.e. a CREATE API request). There is no logic around launching a server and waiting for it to become operational for example.</p>

<h3 id="resources-locating-resources">Locating Resources</h3>

<p>There are a few ways that resources can be located: by type using the <code>get()</code> action on the resource type, by resource href using the <code>get()</code> action on the namespace, or by following links.</p>

<p><strong>Note:</strong> <em>The tags resource type in the rs namespace exposes a <code>by_tag()</code> action which can be used to locate RightScale resources using their tags as well.</em></p>

<h4 id="locating-resources-of-a-given-type">Locating Resources of a Given Type</h4>

<p>The resource type <code>get()</code> action uses arguments specific to each resource type to select which resources should be returned. Different resource types may expose different means of selecting which resources to return. However, most resource types in the <em>rs</em> namespace support a <em>filter</em> argument which can be used to filter resources using one ore more fields (such as the name). Specifying no argument means that no selection is applied and all resources get returned.</p>

<p>The following example demonstrates how to retrieve all the servers living in the RightScale account running a cloud workflow using the <code>get()</code> action:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">()</span>
</code></pre>

<p>Arguments can be used to further select which resources should be returned. For example:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==front_end"</span><span class="p">])</span>
</code></pre>

<p>retrieves a collection consisting of all RightScale servers whose names contain <q>front_end</q>.</p>

<p><strong>Note:</strong> <em>The <code>get()</code> action on a resource type results into an index REST request on the resource type URI. Arguments given to the <code>get()</code> action are mapped to the request query string.</em></p>

<h4 id="locating-resources-by-href">Locating Resources by href</h4>

<p>Locating resources using their href is done via the <code>get()</code> namespace action (which is the only action that exists on namespace resources). The first argument this action takes is the href(s) to the resource(s). The name of the argument is &#39;href&#39; and the value is either a string representing the resource href or an array of strings representing multiple resource hrefs.</p>

<p><strong>Note:</strong> <em>When using an array, all hrefs must point to resources of the same type.</em></p>

<p>Some resource types may support additional arguments, for example some of the resources in the <em>rs</em> namespace support a <em>view</em> argument which can be used to specify what fields from the given resource should be retrieved:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/instances/123"</span><span class="p">,</span> <span class="ss">view: </span><span class="s2">"full"</span><span class="p">)</span>
<span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="p">[</span><span class="s2">"/api/instances/123"</span><span class="p">,</span> <span class="s2">"/api/instances/124"</span><span class="p">],</span> <span class="ss">view: </span><span class="s2">"full"</span><span class="p">)</span>
</code></pre>

<p>The first expression above returns a resource collection made of a single resource: the instance with href <em>/api/instances/123</em>, while the second expression returns a resource collection made up of two instances.</p>

<p><strong>Note:</strong> <em>The <code>namespace get()</code> action results in a get HTTP request on the resource URI for each href.</em></p>

<h4 id="following-namespace-links">Following Namespace Links</h4>

<p>The namespace resource itself can expose top level links. The rs namespace exposes links that allow retrieving resources associated with the account running the cloud workflow. These links can take arguments like filters:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@security_groups</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">security_groups</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==default"</span><span class="p">])</span>
</code></pre>

<p>The code above initializes the <em>@security_groups</em> collection with all the security groups in the account that are named <q>default</q>.</p>

<p><strong>Note:</strong> <em>Namespace links result in get REST requests on the link URI. Arguments given to the link are mapped to the request query string.</em></p>

<h4 id="following-resource-links">Following Resource Links</h4>

<p>Links exposed by resources can be followed to locate resources relatively to others. Links may correspond to one-to-one or one-to-many relationships. For example, the ServerTemplates associated with instances named <em>front_end</em> can be retrieved using:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@template</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/clouds/1234"</span><span class="p">).</span><span class="nf">instances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==frontend"</span><span class="p">]).</span><span class="nf">server_template</span><span class="p">()</span>
</code></pre>

<p>Links can be followed by a call to an action such as:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@clone</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/clouds/1234"</span><span class="p">).</span><span class="nf">instances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==frontend"</span><span class="p">]).</span><span class="nf">server_template</span><span class="p">()</span>
  <span class="p">.</span><span class="nf">clone</span><span class="p">(</span><span class="ss">server_template: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"New name"</span> <span class="p">})</span>
</code></pre>

<p>And if the action returns a resource collection, then links and action can be recursively applied to it:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@images</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">clouds</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/clouds/1234"</span><span class="p">).</span><span class="nf">instances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==frontend"</span><span class="p">]).</span><span class="nf">server_template</span><span class="p">()</span>
  <span class="p">.</span><span class="nf">clone</span><span class="p">(</span><span class="ss">server_template: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"New name"</span> <span class="p">}).</span><span class="nf">multi_cloud_images</span><span class="p">()</span>
</code></pre>

<p>In the example above, the <em>clone</em> action returns a resource collection consisting of all cloned <em>ServerTemplates</em>. The RightScale server_templates resource type exposes a <em>multi_cloud_images</em> link that returns a resource collection made of the multi-cloud images used by the ServerTemplate. The end result is thus a collection made of all multi-cloud images from all cloned ServerTemplates.</p>

<p><strong>Note:</strong> <em>Resource links result in in get REST requests on the link URI. Arguments given to the link are mapped to the request query string.</em></p>

<h3 id="resources-cloud-resource-management">Cloud Resource Management</h3>

<p>Operators and functions allow managing resource collections in various ways. Collections can be merged, extracted, or tested for inclusion.</p>

<p>Collections can be concatenated using the <q>+</q> operator:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@all_servers</span> <span class="o">=</span> <span class="vi">@servers1</span> <span class="o">+</span> <span class="vi">@servers2</span>
</code></pre>

<p>Elements of a collection can be removed from another collection using the <q>-</q> operator:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers1</span> <span class="o">=</span> <span class="vi">@all_servers</span> <span class="o">-</span> <span class="vi">@servers2</span>
</code></pre>

<p><strong>Note:</strong> <em>All instances of all resources in @servers2 are removed from @all_servers.</em></p>

<p>Finally, it is possible to test whether all elements of a collection are contained in another using the <q><</q> and <q>></q> operators:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@all_servers</span> <span class="o">=</span> <span class="vi">@servers1</span> <span class="o">+</span> <span class="vi">@servers2</span>
<span class="vi">@all_servers</span> <span class="o">&gt;</span> <span class="vi">@servers1</span> <span class="c1"># true</span>
<span class="vi">@servers1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="vi">@all_servers</span> <span class="c1"># true</span>
</code></pre>

<p>Cloud workflows can identify specific resources from resource collections in various ways. Items can be extracted by index or range using the bracket operator ([ ]). A range consists of two integers separated by two consecutive dots and is inclusive, like the following:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="vi">@first_server</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="vi">@more_servers</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="mi">3</span><span class="p">]</span>
</code></pre>

<p>The second line evaluates to a collection consisting of a single element: the first server of deployment <em>123</em>. The last line evaluates to a collection containing the second, third, and fourth servers in that deployment. The lower and upper bounds of the range are optional. If no lower bound is specified then the range starts at the first resource in the collection. If no upper bound is specified, then the range ends at the last resource of the collection.</p>

<p><strong>Note:</strong> <em>All indices are zero-based.</em></p>

<p>For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@all_other_servers</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">[</span><span class="mi">1</span><span class="p">.</span><span class="nf">.</span><span class="p">]</span>
</code></pre>

<p>The code above initializes a collection made of all servers in the initial collection except the first.</p>

<p>No error is raised if the specified bounds exceed the number of resources in the collection. Instead, only the resources that are in the specified range are returned:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span><span class="p">[</span><span class="mi">42</span><span class="p">.</span><span class="nf">.</span><span class="p">]</span>
</code></pre>

<p>The example above returns the empty collection if the <em>@servers</em> collection has fewer than 43 resources.</p>

<p>While <em>functions</em> are covered in a different section, it is worth mentioning the <code>size()</code> and <code>select()</code> functions at this point:</p>

<ul>
<li>The <strong>size()</strong> function returns the number of resources in a collection.</li>
<li>The <strong>select()</strong> function traverses a given collection and extracts (selects) all the resources whose fields values match the values given in the second argument (in the form of a hash).</li>
</ul>

<p>The first argument for both these functions is the collection to be traversed while the second argument is a hash of field name and corresponding value. The value may be a regular expression in which case the field must be of type string and its value must match the given regular expression for the resource to be selected. The syntax used to write regular expressions is:</p>

<p><q>/pattern/modifiers</q></p>

<p>where <em>pattern</em> is the regular expression itself, and <em>modifiers</em> are a series of characters indicating various options. The <em>modifiers</em> part is optional. This syntax is borrowed from Ruby (which borrows it from Perl). The following modifiers are supported:</p>

<ul>
<li><strong>/i</strong> makes the regex match case insensitive.</li>
<li><strong>/m</strong> makes the dot match newlines.</li>
<li><strong>/x</strong> ignores whitespace between regex tokens.</li>
</ul>

<p>You can combine multiple modifiers by stringing them together as in <em>/regex/im</em>.</p>

<p>For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="vi">@app_servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"/^app_server.*/i"</span> <span class="p">})</span>
</code></pre>

<p>The above snippet initializes <em>@app_servers</em> with the collection of servers in the deployment with href <em>deployments/123</em> whose name fields start with <em>app_server</em> using a non case sensitive comparison.</p>

<h3 id="resources-passing-resource-collections-to-apis">Passing Resource Collections to APIs</h3>

<p>Using the RightScale APIs to launch a cloud workflow requires giving the expected inputs. Inputs can be variables or resource collections. Variables are specified using the JSON notation. Resource collections are described using a JSON object that contains three fields:</p>

<ul>
<li>The field <code>namespace</code> contains the namespace for the resources in the collection. For example, <em>rs</em></li>
<li>The field <code>type</code> contains the resource type for all resources in the collection. For example, <em>servers</em></li>
<li>Finally the field <code>hrefs</code> is an array of all the resources hrefs. For example, <em>[<q>/api/servers/123</q>, <q>/api/servers/234</q>]</em></li>
</ul>

<p>The Inputs JSON object should contain a field per input whose name matches the input name and whose value contains the corresponding input value. For example:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">launch</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="vg">$timeout</span><span class="p">)</span>
<span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>

<p>For the above cloud workflow, the following input JSON could be used:</p>
<pre class="syntax-highlight ruby"><code><span class="p">{</span>
  <span class="s2">"@servers"</span><span class="p">:</span> <span class="p">{</span> <span class="s2">"namespace"</span><span class="p">:</span> <span class="s2">"rs"</span><span class="p">,</span> <span class="s2">"type"</span><span class="p">:</span> <span class="s2">"servers"</span><span class="p">,</span> <span class="s2">"hrefs"</span><span class="p">:</span> <span class="p">[</span><span class="s2">"/api/servers/234"</span><span class="p">]</span> <span class="p">},</span>
  <span class="s2">"$timeout"</span><span class="p">:</span> <span class="mi">10</span>
<span class="p">}</span>
</code></pre>

<h2 id="definitions">Definitions</h2>

<!-- DEFINITIONS SECTION BEGINS HERE -->

<p>Cloud workflows consist of a sequence of statements. Each statement consists of one or more expressions. The first expression is the <code>define...end</code> block:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">main</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="vg">$wait</span><span class="p">)</span> <span class="k">return</span> <span class="vi">@instances</span><span class="p">,</span> <span class="vg">$duration</span> <span class="k">do</span>
  <span class="vg">$now</span> <span class="o">=</span> <span class="n">now</span><span class="p">()</span>
  <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">if</span> <span class="vg">$wait</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">,</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="vg">$duration</span> <span class="o">=</span> <span class="vg">$now</span> <span class="o">-</span> <span class="n">now</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>A cloud workflow may contain any number of definitions. The special definition called <em>main</em> is the entry point to the process.</p>

<p>Definitions are scoped by the file that contain them: two definitions in the same file cannot have the same name.</p>

<h3 id="definitions-inputs-and-outputs">Inputs and Outputs</h3>

<p>As shown in the snippet above a cloud workflow may specify arguments and return values. There can be zero or more arguments and zero or more return values. Arguments and return values can either be references (<em>@server</em> and <em>@instance</em>) or variables (<em>$wait</em> and <em>$duration</em>), the difference being that references contain resource collections while variables may contain a number, a string, a boolean, a time value, the special <em>null</em> value, an array or a hash (references are described in Cloud Workflow Resources and variables are described in Cloud Workflow Variables).</p>

<p>A cloud workflow may execute children definitions using the <strong>call</strong> keyword:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">launch_servers</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="vg">$wait</span><span class="p">)</span> <span class="k">return</span> <span class="vi">@instances</span><span class="p">,</span> <span class="vg">$duration</span>
<span class="vg">$now</span> <span class="o">=</span> <span class="n">now</span><span class="p">()</span>
  <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">if</span> <span class="vg">$wait</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">,</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="vg">$duration</span> <span class="o">=</span> <span class="vg">$now</span> <span class="o">-</span> <span class="n">now</span><span class="p">()</span>
<span class="k">end</span>

<span class="n">define</span> <span class="n">run_application</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==appserver"</span><span class="p">])</span> <span class="c1"># Get servers with name that contains "appserver"</span>
  <span class="n">call</span> <span class="n">launch_servers</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="kp">true</span><span class="p">)</span> <span class="n">retrieve</span> <span class="vi">@launched_instances</span><span class="p">,</span> <span class="vg">$duration</span>
<span class="k">end</span>
</code></pre>

<p>This <em>run_application</em> definition first initializes the <em>@servers</em> resources collection using a tag query then passes the collection of retrieved servers to the <em>launch_servers</em> definition above. The list of references and variables specified after the <strong>retrieve</strong> keyword matches the list after the <strong>return</strong> keyword of the definition. These references and variables are initialized with the return values of the definition (so in this example the reference <em>@launched_instances</em> of the caller is initialized with the value of the <em>@instances</em> reference returned by <em>launch_servers</em>). The names can match, but don&#39;t have to as shown in the example.</p>

<p><strong>Note:</strong> <em>Using **retrieve</em>* is optional and can be skipped if the caller does not need the return values.*</p>

<h3 id="definitions-structure">Structure</h3>

<p>A cloud workflow is composed of statements. Each statement is in turn made of expressions. Statements are delimited by newlines, semi-colons or both. Comments all start with the <strong>#</strong> symbol. Any character following that symbol on the same line is part of the comment. Blank characters include tabs, spaces and newlines. There can be zero or more blank characters before and after a statement (pending there is a semi-colon if there is no newline). There can also be zero or more blank characters between arguments, operands, and keywords:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># Comments can appear at the end of a line</span>
<span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>

<span class="c1"># is equivalent to:</span>
<span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">();</span>
<span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">));</span>

<span class="c1"># and to:</span>
<span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">();</span> <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
</code></pre>

<p>Sequences of statements are encapsulated in blocks. The outer block is the <code>define...end</code> block however blocks can be defined at any time using the <strong>sub</strong> keyword:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="k">do</span>
  <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_server"</span><span class="p">])</span>
  <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
<span class="nb">sub</span> <span class="k">do</span>
  <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_other_server"</span><span class="p">])</span>
  <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>Using blocks as in the snippet above does not change anything to the execution of the Cloud Workflow (and is thus not that useful...). However, blocks can be used to define scopes for error handlers, timeouts, etc. Blocks also allow defining concurrent activities. For more information about blocks, see the Cloud Workflow Processes section.</p>

<h3 id="definitions-expressions">Expressions</h3>

<p>As mentioned above, a statement consists of a series of expressions. There are four categories of expressions:</p>

<ul>
<li>Resource expressions include calls to resource actions and retrieval of resource links and fields, see Cloud Workflow Resources.</li>
<li>Flow control expressions include block definitions (<strong>define</strong>, <strong>sub</strong>, <strong>concurrent</strong>), conditional expressions (<strong>if</strong>, <strong>else</strong>, <strong>elsif</strong>), and all looping constructs (<strong>while</strong>, <strong>foreach</strong>, <strong>map</strong>, <strong>concurrent foreach</strong>, <strong>concurrent map</strong>), see Branching and Looping.</li>
<li>Operators (<strong>+</strong>, <strong>-</strong>, **<strong><em>, *</em>/</strong>, <strong>%</strong>, <strong>[]</strong>, <strong>==</strong>, <strong>=~</strong>, <strong>&gt;=</strong>, <strong>&lt;=</strong>, <strong>&amp;</strong>, <strong>|</strong>, <strong>!</strong>), see Operators.</li>
<li>Assignments (= and &lt;&lt;), see Operators.</li>
</ul>

<p>Expressions can be adorned with attributes. Attributes do not constitute an expression by themselves. For more information about attributes, see Attributes and Error Handling.</p>

<h2 id="variables">Variables</h2>

<!-- VARIABLES SECTION STARTS HERE -->

<p>A major benefit of using a workflow solution is the consistency and availability properties provided by the system. A simple litmus test for identifying the need for a workflow based solution is answering the question, <q>Where does the state live?</q>  If it&#39;s ok for the state to live on a single system, then running a regular script or program there is probably a simpler solution. Another way to ask the question is this: <q>Is there a system whose failure makes the operation irrelevant?</q>  If such a system exists, then it should be the one driving the operation and keeping the state. For example, if the operation consists of cleaning the temporary files of an instance, then that instance failing makes the operation irrelevant. Therefore, it is OK for it to be responsible for scheduling the operation.</p>

<p>For distributed operations, there is often no simple answer to where state can be kept or where a conventional program can be run. The operation must continue regardless of individual system failures. For example, if the operation consists of analyzing the metrics data on all the instances in a deployment and taking action if certain values reach a given threshold, then no single instance is a good place to run the operation. And a separate <q>management server</q> isn&#39;t good either as it can fail as well. In this case, using a workflow based solution makes sense as the workflow engine is in charge of keeping the state and making sure that the operation is either carried out or gives proper feedback in case of failure. This is obviously not the only reason to use a workflow solution, but state bookkeeping is one of the main perks that come out of it. (Managing concurrent execution of activities is another big one described in the Cloud Workflow Processes section.)</p>

<p>The state of a process is kept in variables and references. References were already covered in Cloud Workflow Resources. They contain collections of resources. A Cloud workflow variables may contain a number, a string, a boolean, a time value, the special null value, an array or a hash. Variables are initialized directly via literal values in code, from resource fields or from the results of a computation. A variable name must start with $ and may contain letters, numbers, and underscores. As with references the naming convention consists of using lower_case. For example:</p>

<ul>
<li>Initializing a variable from a literal value</li>
</ul>
<pre class="syntax-highlight ruby"><code><span class="vg">$variable</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre>

<ul>
<li>Initializing a variable from a resource field:</li>
</ul>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="vg">$names</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span><span class="p">[]</span>
</code></pre>

<p>The above code initializes the $names variable to an array containing the names of all servers in deployment with href /deployments/123.</p>

<p>Accessing a variable that has not been initialized is not an error, it just returns the value null.</p>

<h3 id="variables-writing-explicit-values">Writing Explicit Values</h3>

<p>The syntax used to write explicit values uses the Javascript notation:</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$object</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"rails/app_name"</span><span class="p">:</span> <span class="s2">"Mephisto"</span><span class="p">,</span> <span class="s2">"db_mysql/password"</span><span class="p">:</span> <span class="s2">"cred:DB_PASSWORD"</span><span class="p">,</span> <span class="s2">"app_server/ports"</span><span class="p">:</span> <span class="p">[</span><span class="mi">80</span><span class="p">,</span> <span class="mi">443</span><span class="p">]</span> <span class="p">}</span>
</code></pre>

<p>The above will initialize the $object variable with the given object (hash).</p>

<p>The value stored at a given key of an object can be read using the bracket operator [ ], such as:</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$object</span><span class="p">[</span><span class="s2">"rails/app_name"</span><span class="p">]</span> <span class="c1"># Will resolve to "Mephisto"</span>
</code></pre>

<p>The value stored at a given index of an array field value can also be read using the bracket operator [ ]. For example:</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$object</span><span class="p">[</span><span class="s2">"app_server/ports"</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Will resolve to 80</span>
</code></pre>

<p><strong>Note:</strong> <em>Array indices are 0-based</em></p>

<h3 id="variables-datetime-data-type">Datetime Data Type</h3>

<p>RCL extends the Javascript syntax to add support for the Datetime data type. This type is stored internally as the number of seconds since the epoch and thus supports up to the second granularity. The syntax for writing Datetime values in RCL is:</p>

<p>pre d<q>year/month/day [hours:minutes:seconds] [AM|PM]</q></p>

<p><strong>Note:</strong> <em>Date time values do not include a timezone. If needed the timezone information must be stored separately.</em></p>

<p>Examples are:</p>
<pre class="syntax-highlight ruby"><code><span class="n">d</span><span class="s2">"2012/07/01"</span>
<span class="n">d</span><span class="s2">"2012/07/12 04:21:14 PM"</span>
</code></pre>

<p>If no time is specified then midnight is used (00:00:00). If no AM/PM value is specified then AM is assumed unless the hour value is greater than 12.</p>

<h3 id="variables-operations-on-variables">Operations on Variables</h3>

<p>The language supports a range of operators for dealing with variables including arithmetic operators to manipulate numbers, operators to concatenate strings, arrays, and objects as well as logical operators. Some examples are listed below:</p>

<h4 id="arithmetic:">Arithmetic:</h4>
<pre class="syntax-highlight ruby"><code><span class="vg">$one</span> <span class="o">=</span> <span class="mi">1</span> <span class="c1"># 1</span>
<span class="vg">$two</span> <span class="o">=</span> <span class="mi">2</span> <span class="c1"># 2</span>
<span class="vg">$three</span> <span class="o">=</span> <span class="vg">$one</span> <span class="o">+</span> <span class="vg">$two</span> <span class="c1"># 3</span>
<span class="vg">$four</span> <span class="o">=</span> <span class="vg">$two</span> <span class="o">^</span> <span class="mi">2</span> <span class="c1"># 4</span>
</code></pre>

<h4 id="concatenation-/-merging:">Concatenation / Merging:</h4>
<pre class="syntax-highlight ruby"><code><span class="vg">$string_concat</span> <span class="o">=</span> <span class="s2">"foo"</span> <span class="o">+</span> <span class="s2">"bar"</span> <span class="c1"># "foobar"</span>
<span class="vg">$array_concat</span> <span class="o">=</span> <span class="p">[</span><span class="vg">$one</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span> <span class="c1"># [1, "2", 3, 4]</span>
<span class="vg">$object_merge</span> <span class="o">=</span> <span class="p">{</span> <span class="s2">"one"</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">"two"</span><span class="p">:</span> <span class="mi">2</span> <span class="p">}</span> <span class="o">+</span> <span class="p">{</span> <span class="s2">"one"</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">"three"</span><span class="p">:</span> <span class="mi">3</span> <span class="p">}</span> <span class="c1"># { "one": 1, "two": 2, "three": 3 }</span>
</code></pre>

<h4 id="boolean-operators:">Boolean Operators:</h4>
<pre class="syntax-highlight ruby"><code><span class="vg">$false</span> <span class="o">=</span> <span class="kp">true</span> <span class="o">&amp;&amp;</span> <span class="kp">false</span> <span class="c1"># false</span>
<span class="vg">$true</span> <span class="o">=</span> <span class="kp">true</span> <span class="o">||</span> <span class="kp">false</span> <span class="c1"># true</span>
<span class="vg">$false</span> <span class="o">=</span> <span class="o">!</span><span class="kp">true</span> <span class="c1"># false</span>
<span class="vg">$true</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">==</span> <span class="vg">$one</span> <span class="c1"># true</span>
<span class="vg">$true</span> <span class="o">=</span> <span class="vg">$two</span> <span class="o">&lt;</span> <span class="mi">3</span> <span class="c1"># true</span>
</code></pre>

<h4 id="misc:">Misc:</h4>
<pre class="syntax-highlight ruby"><code><span class="vg">$array_append</span> <span class="o">=</span> <span class="p">[</span><span class="vg">$one</span><span class="p">,</span> <span class="s2">"2"</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span> <span class="c1"># [1, "2", 3]</span>
<span class="vg">$regex_compare</span> <span class="o">=</span> <span class="s2">"hello"</span> <span class="o">=~</span> <span class="s2">"^h"</span> <span class="c1"># true</span>
</code></pre>

<p>Naturally variables can be used wherever values can. The complete list of available operators can be found in the Operators section.</p>

<h3 id="variables-references-and-variables-scope">References and Variables Scope</h3>

<p>RCL supports two types of variables and references: local variables and references are only accessible from a limited scope (defined below) while global variables and references are accessible throughout the execution of the process that defines them.</p>

<h4 id="local-variables,-local-references-and-blocks">Local Variables, Local References and Blocks</h4>

<p>A block in RCL is code contained inside a define, a sub, a if or a loop expression (while, foreach or map).</p>

<p>Both local references and variables are scoped to their containing block and all children blocks. This means that a variable initialized in a parent block can be read and modified by child blocks. Consider the following:</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$variable</span> <span class="o">=</span> <span class="mi">42</span>
<span class="nb">sub</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="vg">$variable</span> <span class="o">==</span> <span class="mi">42</span> <span class="c1"># $variable is "inherited" from parent block</span>
  <span class="vg">$variable</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
<span class="n">assert</span> <span class="vg">$variable</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># $variable is updated in child block</span>
</code></pre>

<p>The scope of $variable in the example above covers the child block, modifying that variable there affects the value in the parent block (or more exactly both the child and parent blocks have access to the same variable).</p>

<p>Note that the scope is limited to the block where a variable or a reference is first defined and child blocks. In particular the value cannot be read from a parent block:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="k">do</span>
  <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_other_server"</span><span class="p">])</span>
    <span class="n">assert</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_other_server"</span> <span class="c1"># true, @servers was "overridden"</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="n">assert</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_other_server"</span> <span class="c1"># true, @servers contains value defined in parent block</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">assert</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_other_server"</span> <span class="c1"># RAISES AN ERROR, @servers is not defined in the parent block</span>
</code></pre>

<h4 id="definitions">Definitions</h4>

<p>The only local variables and references that are defined when a definition starts are the ones passed as arguments. Consider the following:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">main</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_server"</span><span class="p">])</span>
  <span class="vi">@other_servers</span> <span class="o">=</span><span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_other_server"</span><span class="p">])</span>
  <span class="n">call</span> <span class="n">launch_servers</span><span class="p">(</span><span class="vi">@servers</span><span class="p">)</span>
<span class="k">end</span>

<span class="n">define</span> <span class="n">launch_servers</span><span class="p">(</span><span class="vi">@servers</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">assert</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_server"</span> <span class="c1"># @servers contains value passed in arguments</span>
  <span class="n">assert</span> <span class="vi">@other_servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_other_server"</span> <span class="c1"># RAISES AN ERROR, @other_servers is not passed in arguments</span>
<span class="k">end</span>
</code></pre>

<p>In the example above the launch_servers definition does not have access to the @other_servers local reference because it is not listed as an argument.</p>

<h3 id="variables-global-references-and-variables">Global References and Variables</h3>

<p>Sometimes it is useful to retrieve a value defined in an inner block or in one of the sub definitions called via call. Global references and global variables can be used for that purpose as their scope is the entire process rather than the current block. Global references are prefixed with @@, while global variables are prefixed with $$:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="k">do</span>
  <span class="vg">$$</span><span class="n">one</span> <span class="o">=</span> <span class="mi">1</span>
<span class="k">end</span>
<span class="n">assert</span> <span class="vg">$$</span><span class="n">one</span> <span class="o">==</span> <span class="mi">1</span> <span class="c1"># global variable remains set for the entire execution of the process</span>
</code></pre>

<p>Global references and variables exist for the lifetime of the process, independently of where they are set:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">init_servers</span><span class="p">()</span> <span class="k">do</span>
  <span class="vc">@@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/234"</span><span class="p">)</span>
<span class="k">end</span>
<span class="n">call</span> <span class="n">init_servers</span><span class="p">()</span>
<span class="n">assert</span> <span class="vc">@@servers</span><span class="p">.</span><span class="nf">name</span> <span class="o">==</span> <span class="s2">"my_server"</span> <span class="c1"># @@servers set for the entire execution of the process</span>
</code></pre>

<p><strong>Note:</strong> <em>The best practice consists of using return values to retrieve values from a different definition via the return and retrieve attributes as shown in the Cloud Workflows section.</em></p>

<p>Obviously special care needs to be taken when using global references or variables in a process that involves concurrency. For more details, see Cloud Workflow Processes.</p>

<h3 id="variables-use-of-variables-in-place-of-namespace,-type-or-resource-action-or-link">Use of Variables in Place of Namespace, Type or Resource Action or Link</h3>

<p>It is possible to use a Variable in place of a Namespace, etc. An example would be a definition that creates a resource of unspecified type, which is passed as an argument to that definition:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">my_create_method</span><span class="p">(</span><span class="vg">$namespace</span><span class="p">,</span> <span class="vg">$type</span><span class="p">)</span> <span class="k">return</span> <span class="vi">@any</span> <span class="k">do</span>
  <span class="vi">@any</span> <span class="o">=</span> <span class="vg">$namespace</span><span class="o">.</span><span class="vg">$type</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">some_common_arguments: </span><span class="p">{</span> <span class="ss">color: </span><span class="s2">"Saffron"</span> <span class="p">})</span>
<span class="k">end</span>
</code></pre>

<p>A Variable can also be used in place of an action or link for either a Namespace, Type or Resource:</p>
<pre class="syntax-highlight ruby"><code><span class="p">.</span><span class="nf">.</span><span class="o">.</span>
<span class="vg">$action</span> <span class="o">=</span> <span class="s2">"do_stuff"</span>
<span class="vg">$arg</span> <span class="o">=</span> <span class="s2">"stuff"</span>
<span class="n">my_ns</span><span class="o">.</span><span class="vg">$action</span><span class="p">(</span><span class="vg">$arg</span><span class="p">)</span>          <span class="c1"># equivalent to my_ns.do_stuff($arg)</span>
<span class="n">my_ns</span><span class="p">.</span><span class="nf">my_type</span><span class="o">.</span><span class="vg">$action</span><span class="p">(</span><span class="vg">$arg</span><span class="p">)</span>  <span class="c1"># equivalent to my_ns.my_type.do_stuff($arg)</span>
<span class="vi">@my_resource</span><span class="o">.</span><span class="vg">$action</span><span class="p">(</span><span class="vg">$arg</span><span class="p">)</span>   <span class="c1"># equivalent to @my_resource.do_stuff($arg)</span>
<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>

<p>You can also combine multiple uses of Variables in place of Namespace, etc. into a single command:</p>
<pre class="syntax-highlight ruby"><code><span class="p">.</span><span class="nf">.</span><span class="o">.</span>
<span class="vg">$namespace</span> <span class="o">=</span> <span class="s2">"rs"</span>
<span class="vg">$type</span> <span class="o">=</span> <span class="s2">"servers"</span>
<span class="vg">$action</span> <span class="o">=</span> <span class="s2">"get"</span>
<span class="vi">@result</span> <span class="o">=</span> <span class="vg">$namespace</span><span class="o">.</span><span class="vg">$type</span><span class="o">.</span><span class="vg">$action</span><span class="p">(</span><span class="ss">href: </span><span class="vg">$my_href</span><span class="p">)</span>
<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>

<p>Note that a Variable cannot currently be used in place of a field name.</p>

<h2 id="attributes-and-error-handling">Attributes and Error Handling</h2>

<!-- ATTRIBUTES AND ERROR HANDLING SECTION -->

<p>Some statements can be adorned with attributes that affects their behavior. Attributes appear after the statement on the same line right before the <strong>do</strong> keyword for expressions that have one (e.g. <code>define</code>, <code>sub</code>, <code>concurrent</code>, <code>map</code>, <code>foreach</code>). There can be multiple attributes specified on a single statement in which case they are separated with commas. Attributes allow specifying and handling timeouts and handling errors and cancelations.</p>

<p>An attribute has a name and a value. The syntax is: <code>name: value</code></p>

<p>The acceptable types for attribute values depend on the attribute: they may be numbers (e.g. <code>wait_task: 1</code>), strings (e.g. <code>on_timeout: skip</code>), arrays (e.g. <code>wait_task: [ &quot;this_task&quot;, &quot;that_task&quot; ]</code>), or definition names with arguments (e.g. <code>on_timeout: handle_timeout()</code>).</p>

<p>Some of the attributes define behavior that apply to tasks, while others define behavior for the whole process. Processes and tasks are described in detail in the Cloud Workflow Processes section. For the purpose of understanding the attributes behavior described below, it is enough to know that a single process consists of one or more tasks. A task is a single thread of execution.</p>

<p>Some attributes attach behavior to the expression they adorn and all their sub-expressions. The sub-expressions of an expression are expressions that belong to the block defined by the parent expression. Not all expressions define blocks so not all expressions have sub-expressions. Expressions that may have sub-expressions include <code>define</code>, <code>sub</code>, <code>concurrent</code> and the looping expressions (<code>foreach</code>, <code>concurrent foreach</code>, etc.).</p>

<p>The exhaustive list of all attributes supported by the language are listed below in alphabetical order:</p>

<table><thead>
<tr>
<th>Attribute</th>
<th>Applies to</th>
<th>Possible Values</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>on_error</td>
<td>define, sub, call, concurrent</td>
<td>name of the definition with arguments, <strong>skip</strong> or <strong>retry</strong></td>
<td>Behavior to trigger when an error occurs in an expression or a sub-expression. For <code>concurrent</code> blocks, the handler is applied to all sub-expressions.</td>
</tr>
<tr>
<td>on_rollback</td>
<td>define, sub, call, concurrent, concurrent map, concurrent foreach</td>
<td>name of the definition with arguments</td>
<td>Name of the definition called when an expression causes a rollback (due to an error or the task being canceled).</td>
</tr>
<tr>
<td>on_timeout</td>
<td>sub, concurrent, call</td>
<td>name of the definition with arguments, <strong>skip</strong> or <strong>retry</strong></td>
<td>Behavior to trigger when a timeout occurs in an expression or a sub-expression.</td>
</tr>
<tr>
<td>task_name</td>
<td>sub</td>
<td>string representing the name of a task</td>
<td>Change current task name to given value.</td>
</tr>
<tr>
<td>task_prefix</td>
<td>concurrent foreach, concurrent map</td>
<td>string representing the prefix of task names</td>
<td>Specifies the prefix of names of tasks created by concurrent loop (suffix is iteration index).</td>
</tr>
<tr>
<td>timeout</td>
<td>sub, call</td>
<td>string representing a duration</td>
<td>Value defines the maximum time allowed for expressions in a statement and any sub-expression to execute.</td>
</tr>
<tr>
<td>wait_task</td>
<td>concurrent, concurrent foreach, concurrent map</td>
<td>number of tasks to be waited on or name(s) of task(s) to be waited on</td>
<td>Pause the execution of a task until the condition defined by a value is met</td>
</tr>
<tr>
<td>task_label</td>
<td>sub, call, define</td>
<td>string representing label</td>
<td>Labels allow processes to return progress information to clients. They are associated with an arbitrary name that gets returned by the cloud workflow APIs.</td>
</tr>
</tbody></table>

<p>The <code>task_name</code>, <code>task_prefix</code>, and <code>wait_task</code> attributes are described in Cloud Workflow Processes. This section describes in detail the other attributes dealing with errors and timeouts.</p>

<h3 id="attributes-and-error-handling-errors-and-error-handling">Errors and Error Handling</h3>

<p>Defining the steps involved in handling error cases is an integral part of all cloud workflows. This is another area where workflows and traditional programs differ: a workflow needs to describe the steps taken when errors occur the same way it describes the steps taken in the normal flow. Error handlers are thus first class citizen in RCL and are implemented as definitions themselves. Handling an error could mean alerting someone, cleaning up resources, triggering another workflow, etc. RCL makes it possible to do any of these things through the <code>on_error</code> attribute. Only the <code>define</code>, <code>sub</code>, and <code>concurrent</code> expressions may be adorned with that attribute.</p>

<p>The associated value is a string that can be any of the following:</p>

<ul>
<li><strong>skip:</strong> aborts the execution of the statement and any sub-expression then proceeds to the next statement. No cancel handler is called in this case.</li>
<li><strong>retry:</strong> retries the execution of the statement and any sub-expression.</li>
</ul>

<p>To illustrate the behavior associated with the different values consider the following snippet:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">skip</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="s2">"uh oh"</span>
<span class="k">end</span>
<span class="n">log_info</span><span class="p">(</span><span class="s2">"I'm here"</span><span class="p">)</span>
</code></pre>

<p>The engine generates an exception when the <code>raise</code> expression executes. This exception causes the parent expression <code>on_error</code> attribute to execute. The associated value is <strong>skip</strong> which means <em>ignore the error and proceed to run the first expression after the block</em>. The engine then proceeds to the next expression after the block (the <code>log_info</code> expression). If the attribute value associated with the <code>on_error</code> handler had been <strong>retry</strong> instead, then the engine would have proceeded to re-run the block (which in this case would result in an infinite loop).</p>

<p>As mentioned in the introduction, a cloud workflow may need to define additional steps that need to be executed in case of errors. The <code>on_error</code> attribute allows specifying a definition that gets run when an error occurs. The syntax allows for passing arguments to the definition so that the error handler can be provided with contextual information upon invocation. On top of arguments being passed explicitly, the error handler also has access to all the variables and references that were defined in the scope of the expression that raised the error.</p>

<p>The error handler can stipulate how the caller should behave once it completes by assigning one of the string values listed above (<strong>skip</strong> or <strong>retry</strong>) to the special <code>$_error_behavior</code> local variable. If the error definition does not define <code>$_error_behavior</code>, then the caller uses the default behavior (<strong>raise</strong>) after the error definition completes. This default behavior causes the error to be re-raised so that any error handler defined on a parent scope may handle it. If no error handler is defined or all error handlers end-up re-raising then the task terminates and its final status is failed. The <strong>skip</strong> behavior will not raise the error and will force the calling block to skip any remaining expressions after the error occurs. The <strong>retry</strong> behavior will retry the entire caller block again.</p>

<p>The following example shows how to implement a limited number of retries using an error handler:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_retries</span><span class="p">(</span><span class="vg">$attempts</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="vg">$attempts</span> <span class="o">&lt;=</span> <span class="mi">3</span>
    <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"retry"</span>
  <span class="k">else</span>
    <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="vg">$attempts</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">handle_retries</span><span class="p">(</span><span class="vg">$attempts</span><span class="p">)</span> <span class="k">do</span>
  <span class="vg">$attempts</span> <span class="o">=</span> <span class="vg">$attempts</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="p">.</span><span class="nf">.</span><span class="o">.</span> <span class="c1"># Statements that will get retried 3 times in case of errors</span>
<span class="k">end</span>
</code></pre>

<p>Errors can originate from evaluating expressions (e.g. division by 0) or from executing resource actions (e.g. trying to launch an already running server). A variation on the former are errors generated intentionally using the <strong>raise</strong> keyword. In all these cases the most inner error handler defined using the <code>on_error</code> attribute gets executed.</p>

<p>The <strong>raise</strong> keyword optionally followed with a message causes an error which can be caught by an error handler. All error handlers have access to a special variable that contains information about the error being raised. <code>$_error</code> is a hash that contains three keys:</p>

<ul>
<li><strong><q>type</q></strong>: A string that describe the error type. All errors raised using the <strong>raise</strong> keyword have the type set to user.</li>
<li><strong><q>message</q></strong>: A string that contains information specific to this occurrence of the error. The string contains any message given to the <strong>raise</strong> keyword for user errors.</li>
<li><strong><q>origin</q></strong>: A [ <em>line</em>, <em>column</em> ] array pointing at where the error occurred in the RCL source.</li>
</ul>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_error</span><span class="p">()</span> <span class="k">do</span>
  <span class="n">log_error</span><span class="p">(</span><span class="vg">$_error</span><span class="p">[</span><span class="s2">"type"</span><span class="p">]</span> <span class="o">+</span> <span class="s2">": "</span> <span class="o">+</span> <span class="vg">$_error</span><span class="p">[</span><span class="s2">"message"</span><span class="p">])</span> <span class="c1"># Will log "user: ouch"</span>
  <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span>
<span class="k">end</span>
<span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">handle_error</span><span class="p">()</span> <span class="k">do</span>
  <span class="k">raise</span> <span class="s2">"ouch"</span>
<span class="k">end</span>
</code></pre>

<h3 id="attributes-and-error-handling-resource-action-errors">Resource Action Errors</h3>

<p>Resource actions always operate atomically on resource collections, in other words the expression <code>@servers.launch()</code> is semantically equivalent to making concurrent launch API calls to all resources in the <code>@servers</code> array. This means that multiple errors may happen concurrently if multiple resources in the collection fail to run the action. When that happens an error handler needs to have access to the set of resources that failed as well as the set that succeeded and the initial collection to take the appropriate actions. We have already seen the special <code>$_error</code> variable made available to error handlers in case of an error resulting from calling an action on a resource collection. RCL also makes available the following variables to the error handler:</p>

<ul>
<li><em><strong>@_original</strong></em>: The resource collection that initially executed the action that failed.</li>
<li><em><strong>@_done</strong></em>: A resource collection containing all the resources that successfully executed the action.</li>
<li><em><strong>@_partial</strong></em>: A resource collection containing the partial results of the action if the action returns a collection of resources.</li>
<li><em><strong>$_partial</strong></em>: An array containing the partial results of the action if the action returns an array of values.</li>
<li><em><strong>$_errors</strong></em>: An array of hashes containing specific error information.</li>
</ul>

<p>The <code>$_errors</code> variable contains an array of hashes. Each element includes the following values:</p>

<ul>
<li><strong><q>resource_href</q></strong>: Href of the underlying resource on which the action failed, e.g. <q>/account/71/instances/123</q></li>
<li><strong><q>action</q></strong>: Name of the action that failed, e.g. <q>run_executable</q></li>
<li><strong><q>action_arguments</q></strong>: Hash of action arguments as specified in the definition, e.g. { <q>recipe_name</q>: <q>sys:timezone</q> }</li>
<li><strong><q>request</q></strong>: Hash containing information related to the request including the following values...

<ul>
<li><strong><q>url</q></strong>: Full request URL, e.g. <q>https://my.rightscale.com/instances/...run_executable</q></li>
<li><strong><q>verb</q></strong>: HTTP verb used to make the request, e.g. <q>POST</q></li>
<li><strong><q>headers</q></strong>: Hash of HTTP request headers and associated value</li>
<li><strong><q>body</q></strong>: Request body (string)</li>
</ul></li>
<li><strong><q>response</q></strong>: Hash containing information related to the response including the following values...

<ul>
<li><strong><q>code</q></strong>: HTTP response code (string)</li>
<li><strong><q>headers</q></strong>: Hash of HTTP response headers</li>
<li><strong><q>body</q></strong>: Response body (string)</li>
</ul></li>
</ul>

<p>In case of resource action errors the <code>$_error</code> variable is initialized with the type <strong><q>resource_action</q></strong> and includes the detailed error message with the problem, summary, and resolution fields as a string.</p>

<p>Given the above, the following definition implements a retry:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_terminate_error</span><span class="p">()</span> <span class="k">do</span>
  <span class="n">foreach</span> <span class="vg">$error</span> <span class="k">in</span> <span class="vg">$_errors</span> <span class="k">do</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="vg">$error</span><span class="p">[</span><span class="s2">"resource_href"</span><span class="p">])</span> <span class="c1"># Retrieve the instance that failed to terminate</span>
    <span class="k">if</span> <span class="vi">@instance</span><span class="p">.</span><span class="nf">state</span> <span class="o">!=</span> <span class="s2">"stopped"</span>          <span class="c1"># Make sure it is still running</span>
      <span class="n">log_error</span><span class="p">(</span><span class="s2">"Instance "</span> <span class="o">+</span> <span class="vi">@instance</span><span class="p">.</span><span class="nf">name</span> <span class="o">+</span> <span class="s2">" failed to terminate, retrying..."</span><span class="p">)</span>
      <span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">skip</span> <span class="k">do</span>
        <span class="vi">@instance</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span> <span class="c1"># If so try again to terminate but this time ignore any error</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span> <span class="c1"># Proceed with the next statement in caller</span>
<span class="k">end</span>
<span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">handle_terminate_error</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@instances</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>In the definition above the error handler sets the special <code>$_error_behavior</code> local variable to <q>**skip**</q> which means that the process will not raise the error and will instead skip the rest of the block where the error occurred. Note how the handler itself uses <code>on_error</code> to catch errors and ignore them (using skip).</p>

<p>Actions may return nothing, collection of resources, or array of values. In the case an action has a return value (collection or array), the error handler needs to be able to modify that value before it is returned to the calling block. For example, an error handler may retry certain actions and as a result may need to add to the returned value which would initially only contain values for the resources that ran the action successfully. An error handler can achieve this by reading the <code>@_partial</code> collection or the <code>$_partial</code> array, handling the error cases, and returning the complete results as a return value of the error handler definition.</p>

<p>To take a concrete example let&#39;s consider the RightScale servers resource <code>launch()</code> action. This action returns a collection of launched instances. The following handler retries any failure to launch and joins the <code>@_partial</code> collection with instances that successfully launched on retry:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">retry_launch</span><span class="p">()</span> <span class="k">return</span> <span class="vi">@instances</span> <span class="k">do</span>
  <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@_partial</span>
  <span class="n">foreach</span> <span class="vg">$error</span> <span class="k">in</span> <span class="vg">$_errors</span> <span class="k">do</span>
    <span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="vg">$error</span><span class="p">[</span><span class="s2">"resource_href"</span><span class="p">])</span> <span class="c1"># Retrieve the server that failed to launch</span>
    <span class="k">if</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"stopped"</span> <span class="c1"># Make sure it is still stopped</span>
      <span class="n">log_error</span><span class="p">(</span><span class="s2">"Server "</span> <span class="o">+</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">name</span> <span class="o">+</span> <span class="s2">" failed to launch, retrying..."</span><span class="p">)</span>
      <span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">skip</span> <span class="k">do</span>
        <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># If so try again to terminate but this time ignore any error</span>
      <span class="k">end</span>
      <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@instances</span> <span class="o">+</span> <span class="vi">@instance</span> <span class="c1"># @instance may be empty in case the launch failed again</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span> <span class="c1"># Don't raise the error -- skip the rest of the caller block</span>
<span class="k">end</span>
<span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">retry_launch</span><span class="p">()</span> <span class="n">retrieve</span> <span class="vi">@instances</span> <span class="k">do</span>
  <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>The definition above adds any instance that is successfully launched in the retry to the <code>@instances</code> collection as result of any errors in the <code>launch()</code> action.</p>

<h3 id="attributes-and-error-handling-handlers-and-state">Handlers and State</h3>

<p>We&#39;ve seen before that definitions executed via <code>call</code> only have access to the references and variables passed as argument (and global references and variables). Definitions executed through handlers, on the other hand, inherit from all the <em>local</em> variables and references defined at the time the handler is invoked (so at the time an exception is thrown, a timeout occurs or a cancelation is triggered).</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_errors</span> <span class="k">do</span>
 <span class="n">log_error</span><span class="p">(</span><span class="s2">"Process failed while handling "</span> <span class="o">+</span> <span class="nb">inspect</span><span class="p">(</span><span class="vi">@servers</span><span class="p">))</span> <span class="c1"># Note: handler has access to @servers</span>
 <span class="vg">$_error_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span>
<span class="k">end</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/123"</span><span class="p">)</span>
<span class="nb">sub</span> <span class="ss">on_error: </span><span class="n">handle_errors</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>In the snippet above, the error handler has access to <code>@servers</code> even though that collection is defined in the main scope (the various <code>log_xxx()</code> functions allow for appending messages to process logs and the <code>inspect()</code> function produces a human friendly string representation of the object it is given).</p>

<h3 id="attributes-and-error-handling-timeouts">Timeouts</h3>

<p>The <code>timeout</code> and <code>on_timeout</code> attributes allow setting time limits on the execution of expressions and specifying the behavior when a time limit is reached respectively:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="ss">timeout: </span><span class="mi">30</span><span class="n">m</span><span class="p">,</span> <span class="ss">on_timeout: </span><span class="n">handle_launch_timeout</span><span class="p">()</span> <span class="k">do</span>
  <span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/server/1234"</span><span class="p">)</span>
  <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@instance</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span>
  <span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/1235"</span><span class="p">)</span>
  <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@instance</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>The block in the snippet above must execute in less than 30 minutes otherwise its execution is canceled and the <code>handle_launch_timeout</code> definition is executed. Timeout values can be suffixed with <strong>d</strong>, <strong>h</strong>, <strong>m</strong>, or <strong>s</strong> (respectively day, hour, minute or second).</p>

<p>Note that there does not need to be a <code>on_timeout</code> associated with all timeout attributes. Instead the most inner expression that includes the <code>on_timeout</code> attribute gets triggered when a timeout occurs:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="ss">on_timeout: </span><span class="n">outer_handler</span><span class="p">()</span> <span class="k">do</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">sub</span> <span class="ss">timeout: </span><span class="mi">10</span><span class="n">m</span><span class="p">,</span> <span class="ss">on_timeout: </span><span class="n">inner_handler</span><span class="p">()</span> <span class="k">do</span>
    <span class="p">.</span><span class="nf">.</span><span class="o">.</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@instance</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
  <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
<span class="nf">end</span>
</code></pre>

<p>In the snippet above, <code>inner_handler</code> gets executed if the <code>sleep_until</code> function takes more than 10 minutes to return.</p>

<p>Similar to the <code>on_error</code> attribute, the <code>on_timeout</code> attribute can be followed by a definition name or one of the behaviors values (<strong>skip</strong> or <strong>retry</strong>).</p>

<p><strong>Note:</strong> <em>Using the raise behavior in an <code>on_timeout</code> attribute will cause the next <code>on_timeout</code> handler to be executed. Timeouts never cause error handlers to be executed and vice-versa.</em></p>

<p>On top of specifying the behavior directly in the <code>on_timeout</code> attribute as in:</p>
<pre class="syntax-highlight ruby"><code><span class="nb">sub</span> <span class="ss">timeout: </span><span class="mi">10</span><span class="n">m</span><span class="p">,</span> <span class="ss">on_timeout: </span><span class="n">skip</span> <span class="k">do</span>
  <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>It&#39;s also possible for a definition handling the timeout to specify what the behavior should be by setting the <code>$_timeout_behavior</code> local variable:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_timeout</span><span class="p">()</span> <span class="k">do</span>
  <span class="vg">$_timeout_behavior</span> <span class="o">=</span> <span class="s2">"retry"</span>
<span class="k">end</span>
</code></pre>

<p>Finally, the timeout handler may accept arguments that can be specified with the <code>on_timeout</code> attribute. The values of the references and variables at the point when the timeout occurs are given to the handler:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">handle_timeout</span><span class="p">(</span><span class="vg">$retries</span><span class="p">)</span> <span class="k">do</span>
  <span class="k">if</span> <span class="vg">$retries</span> <span class="o">&lt;</span>  <span class="mi">3</span>
    <span class="vg">$_timeout_behavior</span> <span class="o">=</span> <span class="s2">"retry"</span>
  <span class="k">else</span>
    <span class="vg">$_timeout_behavior</span> <span class="o">=</span> <span class="s2">"skip"</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="vg">$retries</span> <span class="o">=</span> <span class="mi">0</span>
<span class="nb">sub</span> <span class="ss">timeout: </span><span class="mi">10</span><span class="n">m</span><span class="p">,</span> <span class="ss">on_timeout: </span><span class="n">handle_timeout</span><span class="p">(</span><span class="vg">$retries</span><span class="p">)</span> <span class="k">do</span>
  <span class="vg">$retries</span> <span class="o">=</span> <span class="vg">$retries</span> <span class="o">+</span> <span class="mi">1</span>
  <span class="nb">sleep</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="mi">60</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="c1"># Force the timeout handler to trigger</span>
<span class="k">end</span>
</code></pre>

<p>The snippet above will cause the <code>handle_timeout</code> definition to execute three times. The third times <code>$retries</code> is equal to 3, the timeout handler definition sets <code>$_timeout_handler</code> to skip and the block is canceled.</p>

<h3 id="attributes-and-error-handling-labels">Labels</h3>

<p>The <code>task_label</code> attribute is used to report progress information to clients. It does not affect the execution of the process and is simply a way to report what it is currently doing. The label attribute can be used on <code>sub</code> and <code>call</code>:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">main</span><span class="p">()</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_label: </span><span class="s2">"Initialization"</span> <span class="k">do</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
  <span class="nb">sub</span> <span class="ss">task_label: </span><span class="s2">"Launching servers"</span> <span class="k">do</span>
    <span class="p">.</span><span class="nf">.</span><span class="p">.</span>
  <span class="nf">end</span>
  <span class="n">call</span> <span class="n">setup_app</span><span class="p">()</span> <span class="ss">task_label: </span><span class="s2">"Setting up application"</span>
<span class="k">end</span>
</code></pre>

<h3 id="attributes-and-error-handling-summary">Summary</h3>

<p>We have seen how a cloud workflow may use attributes to annotate statements and defining additional behaviors. Attributes apply to the statement they adorned and some also apply to its sub-expressions. Definitions can be written to handle errors, timeouts and cancelation. Definitions handling errors that occur during resource action execution have access to all the underlying low level errors and can modify the return value of the action.</p>

<h2 id="branching-and-looping">Branching and Looping</h2>

<h3 id="branching-and-looping-branching">Branching</h3>

<p>Branching is done using the customary <code>if</code> keyword. This keyword marks the beginning of a block (like <code>sub</code>). It must be followed by an expression that must resolve to a value. If the value is <code>false</code> or <code>null</code>, then the expressions in the block are skipped; otherwise they are executed sequentially.</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/123"</span><span class="p">)</span>
<span class="k">if</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span>
  <span class="vi">@server</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>RCL also supports the <code>else</code> keyword with the usual meaning:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/123"</span><span class="p">)</span>
<span class="k">if</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span>
  <span class="vi">@server</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span>
<span class="k">else</span>
  <span class="k">if</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"terminated"</span>
    <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Finally, RCL also supports the <code>elsif</code> keyword which can be used to write the example above more succinctly:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/123"</span><span class="p">)</span>
<span class="k">if</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span>
  <span class="vi">@server</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span>
<span class="k">elsif</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"terminated"</span>
  <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
<span class="k">end</span>
</code></pre>

<p>This notation is especially useful to chain multiple tests without having to keep indenting the code.</p>

<h3 id="branching-and-looping-looping">Looping</h3>

<p>There are three different kinds of loops: the traditional <code>while</code> loop allows repeating a block until a given condition is met. The <code>foreach</code> loop allows iterating over a resource collection, a range, or an array of values. Finally the <code>map</code> loop is also an iterator but it returns one or more collection(s) built from the elements of the initial collection.</p>

<h4 id="while-loops">While Loops</h4>

<p>The <code>while</code> keyword marks the beginning of a block. It must be followed by an expression that resolves to a value. The sub-expressions are executed until the value resolves to false or null:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># Assumes $app_servers_count, $app_server_definition and $server_name have previously been defined</span>
<span class="vg">$count</span> <span class="o">=</span> <span class="mi">0</span>
<span class="k">while</span> <span class="vg">$count</span> <span class="o">&lt;</span> <span class="vg">$app_servers_count</span> <span class="k">do</span>
  <span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">server</span><span class="p">.</span><span class="nf">create</span><span class="p">({</span> <span class="s2">"name"</span><span class="p">:</span> <span class="vg">$server_name</span> <span class="o">+</span> <span class="s2">"_"</span> <span class="o">+</span> <span class="vg">$count</span> <span class="p">}</span> <span class="o">+</span> <span class="vg">$app_server_definition</span><span class="p">)</span>
  <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="vg">$count</span> <span class="o">=</span> <span class="vg">$count</span> <span class="o">+</span> <span class="mi">1</span>
<span class="k">end</span>
</code></pre>

<p>This example will loop <code>$app_servers_count</code> times and in each iteration will create a server using a given set of arguments and launch it. The <code>+</code> operator applied to hashes returns a hash built from merging the left hand side of the operator into the right hand side. The same operator following a string concatenates the string with the right hand side value (a string or an integer). So the loop body in the example above will override the name used to create the server using a common prefix and the index as suffix.</p>

<h4 id="foreach-loops">Foreach Loops</h4>

<p>Foreach loops allow iterating over either a resource collection, a range, or an array of values. The syntax is:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="vg">$recipes</span> <span class="o">=</span> <span class="p">[</span><span class="s2">"cassandra::default"</span><span class="p">,</span> <span class="s2">"cassandra::configure"</span><span class="p">,</span> <span class="s2">"cassandra::restart"</span><span class="p">]</span>
<span class="n">foreach</span> <span class="vg">$recipe</span> <span class="k">in</span> <span class="vg">$recipes</span> <span class="k">do</span>
  <span class="vi">@servers</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="vg">$recipe</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>
<pre class="syntax-highlight ruby"><code><span class="vi">@deployment</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">)</span>
<span class="n">foreach</span> <span class="vg">$name</span> <span class="k">in</span> <span class="p">[</span><span class="s2">"clone-1"</span><span class="p">.</span><span class="nf">.</span><span class="s2">"clone-3"</span><span class="p">]</span> <span class="k">do</span>
  <span class="vi">@deployment</span><span class="p">.</span><span class="nf">clone</span><span class="p">(</span><span class="ss">deployment: </span><span class="p">{</span> <span class="ss">name: </span><span class="vg">$name</span> <span class="p">})</span>
<span class="k">end</span>
</code></pre>

<p>As mentioned above, <code>foreach</code> also allows iterating through collections as in:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="n">foreach</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@servers</span> <span class="k">do</span>
  <span class="n">call</span> <span class="n">audit_server</span><span class="p">(</span><span class="vi">@server</span><span class="p">.</span><span class="nf">name</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p><strong>Note:</strong> <em>A cloud workflow always acts on resource collections, the elements returned by <code>foreach</code> are thus collections themselves (albeit made of a single resource).</em></p>

<h4 id="map-loops">Map Loops</h4>

<p>The <code>map</code> iterator constructs a new collection by iterating over an existing collection and applying a transformation to each element. The full form of the <code>map</code> iterator is fairly flexible and can iterate over a collection, a range, or an array of values, and it can construct one or multiple collections or arrays of values. The example below shows it iterating over the <code>@servers</code> collection and producing a <code>$states</code> array of values and <code>@instances</code> collection.</p>

<p>The <code>map</code> iterator follows the same syntax as the <code>foreach</code> operator, but adds a <code>return</code> keyword used to specify which variable(s) or reference(s) from the inner block should be used to build the resulting arrays(s)/collection(s).</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="vg">$states</span><span class="p">,</span> <span class="vi">@instances</span> <span class="o">=</span> <span class="n">map</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@servers</span> <span class="k">return</span> <span class="vg">$state</span><span class="p">,</span> <span class="vi">@instance</span> <span class="k">do</span>
  <span class="vg">$state</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">state</span>
  <span class="k">if</span> <span class="vg">$state</span> <span class="o">==</span> <span class="s2">"stopped"</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">else</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">current_instance</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>The above code creates two collections: the resource collection <code>@instances</code> and an the array <code>$states</code>. The <code>@instances</code> resource collection gets built by appending the content of <code>@instance</code> at the end of each iteration. Similarly, <code>$states</code> gets built by appending the value of <code>$state</code> at the end of each iteration. If a reference or a variable specified after <code>return</code> does not get defined in the execution of an iteration, then nothing is appended to the corresponding resulting collection.</p>

<h2 id="processes">Processes</h2>

<h3 id="processes-process-overview">Process Overview</h3>

<p>Control over the timing of execution of activities is another area that differentiates workflows from traditional programs. A cloud workflow allows for describing explicitly how multiple activities are orchestrated: whether they run sequentially or concurrently and when to synchronize.</p>

<p>The building blocks for describing the sequencing are the <code>sub</code> and <code>concurrent</code> expressions. All sub-expressions of a <code>sub</code> expression execute sequentially while all sub-expressions of a <code>concurrent</code> expression execute concurrently. <code>sub</code> expressions can be nested inside <code>concurrent</code> expressions and vice versa providing the mean for describing what runs concurrently and when to synchronize.</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="k">do</span> <span class="c1"># the following two blocks execute concurrently</span>
  <span class="nb">sub</span> <span class="k">do</span> <span class="c1"># Expressions below (until 'end') execute sequentially</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_server"</span><span class="p">])</span>
    <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">,</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==my_other_server"</span><span class="p">])</span>
    <span class="vi">@instances</span> <span class="o">=</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@instances</span><span class="p">.</span><span class="nf">state</span><span class="p">,</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span> <span class="c1"># Marks the synchronization point for the concurrence</span>
<span class="c1"># At this point all servers are operational: both concurrent sequences are finished.</span>
</code></pre>

<h3 id="processes-process-tasks">Process Tasks</h3>

<p>All activities taking place in a process occur in tasks. Each iteration of a <code>concurrent foreach</code> expression runs in its own task. Processes start with one task: the <code>main</code> task. The <code>task_name</code> attribute can be used to adorn sub-expressions of the <code>concurrent</code> expression to name tasks. This attribute can be specified on any expression (changing the name of the current task each time). However, the convention is to adorn the outer <code>sub</code> expression if there is one. That name can then be used to <code>wait</code> for that task:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># Update code on app servers</span>
<span class="n">define</span> <span class="n">update_code</span><span class="p">(</span><span class="vi">@app_servers</span><span class="p">,</span> <span class="vg">$branch</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># Obtain the current branch (through a tag in one of the app server)</span>
  <span class="n">call</span> <span class="n">get_current_branch</span><span class="p">(</span><span class="n">first</span><span class="p">(</span><span class="vi">@app_servers</span><span class="p">))</span> <span class="n">retrieve</span> <span class="vg">$previous_branch</span>

  <span class="c1"># Concurrently pull code on all app servers</span>
  <span class="n">concurrent</span> <span class="n">foreach</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@app_servers</span> <span class="ss">task_prefix: </span><span class="s2">"codepull"</span><span class="p">,</span> <span class="ss">timeout: </span><span class="mi">10</span><span class="n">m</span> <span class="k">do</span>
    <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"app::pull_code"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">branch: </span><span class="vg">$branch</span> <span class="p">})</span>
  <span class="k">end</span>

  <span class="c1"># Perform a rolling update on all app servers (detech from loadbalancer, restart service, attach to load balancer)</span>
  <span class="n">foreach</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@app_servers</span> <span class="ss">task_prefix: </span><span class="s2">"restart"</span><span class="p">,</span> <span class="ss">on_rollback: </span><span class="n">rollback_code_update</span><span class="p">(),</span> <span class="ss">on_error: </span><span class="n">handle_update_error</span><span class="p">()</span> <span class="k">do</span>
    <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"lb::detach"</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"app::restart"</span><span class="p">,</span> <span class="p">{})</span>
    <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"lb::attach"</span><span class="p">,</span> <span class="p">{})</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="n">define</span> <span class="n">rollback_code_update</span><span class="p">()</span> <span class="k">do</span>
  <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"app:pull_code"</span><span class="p">,</span> <span class="p">{</span> <span class="ss">branch: </span><span class="vg">$previous_branch</span> <span class="p">})</span>
  <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"app::restart"</span><span class="p">,</span> <span class="p">{})</span>
  <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@server</span><span class="p">,</span> <span class="s2">"lb::attach"</span><span class="p">,</span> <span class="p">{})</span>
<span class="k">end</span>

<span class="n">define</span> <span class="n">handle_update_error</span><span class="p">()</span> <span class="k">do</span>
  <span class="n">cancel_task</span>
<span class="k">end</span>

<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
</code></pre>

<p>The snippet above pulls code on all application services concurrently. Once the code pull is completed, the service is restarted on each application service sequentially. Any error during this process will cancel the task using <code>cancel_task</code> keyword which rolls the code back to the previous known working version.</p>

<h4 id="task-names">Task Names</h4>

<p>Tasks can be referred to using two different names: the local name (used in the example above) is the name used with the <code>task_name</code> attribute. This name can only be used to refer to a task that is a sibling, that is a task that was launched by the same task that also launched the task using the name. The other way to address a task is to use its global name: this name is defined using the parent tasks names recursively (excluding the main task) combined with the current task name using / as separator:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"grand_parent"</span> <span class="k">do</span>
    <span class="n">concurrent</span> <span class="k">do</span>
      <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"parent"</span> <span class="k">do</span>
        <span class="n">concurrent</span> <span class="k">do</span>
          <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"child"</span> <span class="k">do</span>
            <span class="c1"># do something</span>
          <span class="k">end</span>
          <span class="n">concurrent</span> <span class="k">do</span>
            <span class="nb">sub</span> <span class="k">do</span>
              <span class="n">wait_task</span> <span class="n">grand_parent</span><span class="o">/</span><span class="n">parent</span><span class="o">/</span><span class="n">child</span> <span class="c1"># cannot use local name for 'child' task because</span>
                                                  <span class="c1"># not in a sibling task</span>
              <span class="c1"># do something</span>
            <span class="k">end</span>
            <span class="nb">sub</span> <span class="k">do</span>
              <span class="c1"># do something</span>
            <span class="k">end</span>
          <span class="k">end</span>
        <span class="k">end</span>
      <span class="k">end</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Tasks that are not explicitly named using the <code>task_name</code> attribute get assigned a unique name by the engine. The <code>task_name()</code> function (functions are covered in the next section) returns the global name of the current task.</p>

<p>Task names must be strings or variables containing strings:</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$name</span> <span class="o">=</span> <span class="s2">"foo"</span>
<span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="vg">$name</span> <span class="k">do</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="n">wait_task</span> <span class="vg">$name</span>
    <span class="c1"># do something</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<h4 id="controlling-tasks">Controlling Tasks</h4>

<p>As mentioned earlier tasks can be canceled or aborted. The respective keywords are <code>cancel_task</code> and <code>abort_task</code> and they will apply to the task executing this action.</p>

<p>A process can also be canceled or aborted in its entirety using respectively the <code>cancel</code> or <code>abort</code> keyword. Executing any of these has the same effect as executing the corresponding task version in all currently running tasks. In particular, this means that canceling or aborting a process will take effect once all tasks have finished running their current expression. The exact behavior of canceling and aborting are described below in the Ending Cloud Workflow processes section.</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># If an error occurs during launch then cancel all launching tasks and terminate all servers.</span>
<span class="n">define</span> <span class="n">cancel_launch</span><span class="p">(</span><span class="vi">@servers</span><span class="p">)</span> <span class="k">do</span>
  <span class="c1"># Wait for the other task to finish before terminating the servers and canceling the process.</span>
  <span class="k">if</span> <span class="n">task_name</span><span class="p">()</span> <span class="o">==</span> <span class="s2">"/root/launch_app_server"</span>
    <span class="n">wait_task</span> <span class="n">launch_app_fe</span>
  <span class="k">else</span>
    <span class="n">wait_task</span> <span class="n">launch_app_server</span>
  <span class="k">end</span>
  <span class="vi">@servers</span><span class="p">.</span><span class="nf">terminate</span><span class="p">()</span>
  <span class="n">cancel</span>
<span class="k">end</span>

<span class="p">.</span><span class="nf">.</span><span class="o">.</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==default"</span><span class="p">]).</span><span class="nf">servers</span><span class="p">()</span> <span class="c1"># Retrieve all servers of "default" deployment</span>
<span class="n">concurrent</span> <span class="k">return</span> <span class="vi">@app_servers</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_server"</span><span class="p">,</span> <span class="ss">on_error: </span><span class="n">cancel_launch</span><span class="p">(</span><span class="vi">@servers</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@app_servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"app_server"</span> <span class="p">})</span> <span class="c1"># Select servers named "app_server"</span>
    <span class="vi">@app_servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>                                     <span class="c1"># and launch them</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_fe"</span><span class="p">,</span> <span class="ss">on_error: </span><span class="n">cancel_launch</span><span class="p">(</span><span class="vi">@servers</span><span class="p">)</span> <span class="k">do</span>
    <span class="vi">@fe_servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"front_end"</span> <span class="p">})</span>  <span class="c1"># Select servers named "front_end"</span>
    <span class="vi">@fe_servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>                                     <span class="c1"># and launch them</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@app_servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>       <span class="c1"># Wait until all app servers are operational</span>
</code></pre>

<h4 id="checking-for-tasks">Checking for Tasks</h4>

<p>As covered earlier a task can be waited on using the <code>wait_task</code> keyword. The current task blocks until the given task finishes (i.e. completes, fails, is canceled, or is aborted). If the given task is not even started, the current task will wait until it is started before waiting for it to finish. This keyword will have no effect if the task has already completed, but will raise an error if there is no task with the given name.</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==default"</span><span class="p">]).</span><span class="nf">servers</span><span class="p">()</span>
<span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_server"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="ss">name: </span><span class="s2">"app_server"</span> <span class="p">})</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
    <span class="c1"># Wait for load balancers to become available</span>
    <span class="n">wait_task</span> <span class="n">launch_app_fe</span>
    <span class="n">call</span> <span class="n">run_recipe</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="s2">"lb::attach"</span><span class="p">,</span> <span class="p">{})</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_fe"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="ss">name: </span><span class="s2">"front_end"</span> <span class="p">})</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p><code>wait_task</code> can also be used with a number indicating the number of tasks that should be waited on. The task running the <code>wait_task</code> expression blocks until the given number of tasks complete. Note that this form is mostly useful when used as an attribute on a concurrent expression to indicate how many concurrent tasks should complete before the next expression runs.</p>

<p>Finally, <code>wait_task</code> also accepts an array of task names corresponding to the tasks that should complete prior to the execution resuming. This form can also be used as an attribute:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="s2">"name==default"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
<span class="n">concurrent</span> <span class="ss">wait_task: </span><span class="p">[</span><span class="n">launch_app_server</span><span class="p">,</span> <span class="n">launch_app_fe</span><span class="p">]</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_server"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"app_server"</span> <span class="p">})</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"launch_app_fe"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"front_end"</span> <span class="p">})</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="nb">select</span><span class="p">(</span><span class="vi">@servers</span><span class="p">,</span> <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"diagnostics_servers"</span> <span class="p">})</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="c1"># At this point the diagnostics servers may not have been launched yet (the last sub block may not have completed)</span>
</code></pre>

<h3 id="processes-synchronization-primitives">Synchronization Primitives</h3>

<p>The most basic synchronization primitive is a bare <code>concurrent</code> expression. Each sub-expression of <code>concurrent</code> expression runs in its own task. This expression will block until all sub-expressions have completed. Sometimes more control is needed. For example, it may suffice for one of the <code>concurrent</code> expressions to finish before proceeding. The <code>concurrent</code> expression <code>wait_task</code> attribute can be used in two different ways to provide the additional control:</p>

<ul>
<li>When <code>wait_task</code> is followed by an integer, the <code>concurrent</code> expression will return after the corresponding number of tasks have completed.</li>
<li>When <code>wait_task</code> is followed by a list of task names, the <code>concurrent</code> expression will return after the corresponding tasks have completed.</li>
</ul>

<p>In the following example:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="ss">wait_task: </span><span class="mi">1</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==app_server_1"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==app_server_2"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># At this point at least one of the sequences above has completed</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==front_end"</span><span class="p">])</span>
<span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre>

<p>The front-ends will be launched as soon as either all servers whose names match <code>app_server_1</code> or servers whose names match <code>app_server_2</code> are operational. As stated above tasks can be waited on using their names:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="ss">wait_task: </span><span class="n">databases</span><span class="p">,</span> <span class="n">app_servers</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"databases"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==database"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"app_servers"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==app_server"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
    <span class="n">sleep_until</span><span class="p">(</span><span class="n">all?</span><span class="p">(</span><span class="vi">@servers</span><span class="p">.</span><span class="nf">state</span><span class="p">[],</span> <span class="s2">"operational"</span><span class="p">))</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"additional"</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==additional"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># At this point the databases and app_servers tasks have completed</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==front_end"</span><span class="p">])</span>
<span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre>

<p>One interesting application of the <code>wait_task</code> attribute is when used in conjunction with the number <code>0</code> as follows:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="ss">wait_task: </span><span class="mi">0</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==database"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==app_server"</span><span class="p">])</span>
    <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>

<span class="c1"># At this point tasks above have not completed</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==diag_server"</span><span class="p">])</span>
<span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
</code></pre>

<p>In this case, the process proceeds past the <code>concurrent</code> expression without waiting for any of the launched tasks. This is the same behavior as wrapping the whole definition extract above in an outer <code>concurrent</code>.</p>

<h3 id="processes-tasks-and-state">Tasks and State</h3>

<p>Whenever a task is launched it gets its own copy of the parent task state. This includes all references and all variables currently defined in the parent task.</p>
<pre class="syntax-highlight ruby"><code><span class="vg">$n</span> <span class="o">=</span> <span class="mi">3</span>
<span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==default"</span><span class="p">]).</span><span class="nf">servers</span><span class="p">()</span>
<span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="c1"># $n is equal to 3 and @servers contain all servers in the "default" deployment</span>
    <span class="vg">$n</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name==other"</span><span class="p">]).</span><span class="nf">servers</span><span class="p">()</span>
    <span class="c1"># $n is equal to 5 and @servers contain all servers in the "other" deployment</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="c1"># $n is equal to 3 and @servers contain all servers in the "default" deployment</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Once a task finishes its state is discarded, however, it is sometimes necessary to retrieve state from a different task. RCL provides two mechanisms to share state across tasks:</p>

<ul>
<li>The values for global references and variables are stored in the process, they can be written to and read from by any task.</li>
<li>A <code>concurrent</code> sub expression may optionally <code>return</code> local variables or references. Such values are merged back into the parent task. If multiple tasks in the concurrence return the same value then the behavior is undefined; in other words the code needs to use different names for values returned by different tasks.</li>
</ul>

<p>Here is an example using the <code>return</code> keyword:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">main</span><span class="p">(</span><span class="vi">@server1</span><span class="p">,</span> <span class="vi">@server2</span><span class="p">)</span> <span class="k">return</span> <span class="vi">@server1</span><span class="p">,</span> <span class="vi">@server2</span> <span class="k">do</span>
  <span class="n">concurrent</span> <span class="k">return</span> <span class="vi">@server1</span><span class="p">,</span> <span class="vi">@server2</span> <span class="k">do</span>
    <span class="nb">sub</span> <span class="k">do</span>
      <span class="n">provision</span><span class="p">(</span><span class="vi">@server1</span><span class="p">)</span>
    <span class="k">end</span>
    <span class="nb">sub</span> <span class="k">do</span>
      <span class="n">provision</span><span class="p">(</span><span class="vi">@server2</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="c1"># @server1 and @server2 are now operational</span>
<span class="k">end</span>
</code></pre>

<h3 id="processes-concurrent-foreach">concurrent foreach</h3>

<p>Another way to create tasks in a process apart from <code>concurrent</code> is through the <code>concurrent foreach</code> expression. This expression runs all sub-expressions in sequence on all resources in the given resources collection concurrently. In other words a task is created for each resource in the collection:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@instances</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">().</span><span class="nf">current_instance</span><span class="p">()</span>
<span class="n">concurrent</span> <span class="n">foreach</span> <span class="vi">@instance</span> <span class="k">in</span> <span class="vi">@instances</span> <span class="k">do</span>
  <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::default"</span><span class="p">)</span>
  <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::configure"</span><span class="p">)</span>
  <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::restart"</span><span class="p">)</span>
<span class="k">end</span>
</code></pre>

<p>In the snippet above, the three RightScripts get run sequentially on all servers in the collection at once. If the <code>@servers</code> collection in the example above contained two resources the following would have the same effect:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@instances</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">().</span><span class="nf">current_instance</span><span class="p">()</span>
<span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@instances</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::default"</span><span class="p">)</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::configure"</span><span class="p">)</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::restart"</span><span class="p">)</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@instances</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::default"</span><span class="p">)</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::configure"</span><span class="p">)</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::restart"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>Sometimes it is necessary to explicitly refer to one of the tasks that was spawned from the <code>concurrent foreach</code> execution. The <code>task_prefix</code> attribute is only valid for the <code>concurrent foreach</code> expression and allows defining a common prefix for all generated tasks. The task names are built from the prefix and the index of the resource in the collection:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="ss">task_name: </span><span class="s2">"run_scripts"</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>
    <span class="n">concurrent</span> <span class="n">foreach</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@servers</span> <span class="ss">task_prefix: </span><span class="n">cassandra_setup</span> <span class="k">do</span>
      <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">current_instance</span><span class="p">()</span>
      <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::default"</span><span class="p">)</span>
      <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::configure"</span><span class="p">)</span>
      <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"cassandra::restart"</span><span class="p">)</span>
    <span class="k">end</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="n">wait_task</span> <span class="n">run_scripts</span><span class="o">/</span><span class="n">cassandra_setup0</span> <span class="c1"># Wait for execution of scripts on first server in collection above to complete</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In the example above, <code>cassandra_setup0</code> refers to the task generated to run the <code>concurrent foreach</code> sub-expressions on the first resource in the <code>@servers</code> collection.</p>

<h3 id="processes-concurrent-map">concurrent map</h3>

<p>Apart from <code>concurrent</code> and <code>concurrent foreach</code>, <code>concurrent map</code> is the only other way to create tasks in a process. A <code>concurrent map</code> works as expected: each iteration runs concurrently and the resulting collections are built from the results of each iteration.</p>

<p><strong>Note:</strong> <em>Even though the resulting collections are built concurrently, <code>concurrent map</code> guarantees that the order of elements in the final collection(s) match the order of the collection being iterated on.</em></p>

<p>So, for example:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">()</span>

<span class="c1"># Launch all servers concurrently and conditionally run a script on the resulting</span>
<span class="c1"># instance once it is operational.</span>
<span class="vi">@instances</span> <span class="o">=</span> <span class="n">concurrent</span> <span class="n">map</span> <span class="vi">@server</span> <span class="k">in</span> <span class="vi">@servers</span> <span class="k">return</span> <span class="vi">@instance</span> <span class="k">do</span>
  <span class="vi">@instance</span> <span class="o">=</span> <span class="vi">@server</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span>
  <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@instance</span><span class="p">.</span><span class="nf">state</span> <span class="o">==</span> <span class="s2">"operational"</span><span class="p">)</span>
  <span class="k">if</span> <span class="vi">@instance</span><span class="p">.</span><span class="nf">name</span> <span class="o">=~</span> <span class="s2">"/^app_/"</span>
    <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"app::connect"</span><span class="p">)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In the example above the instances in the <code>@instances</code> collection will be ordered identically to the servers in the <code>@servers</code> collection (that is, the instance at a given index in the <code>@instances</code> collection will correspond to the server at the same index in the <code>@servers</code> collection).</p>

<h3 id="processes-ending-processes">Ending processes</h3>

<p>A process ends once all its tasks end. There are four conditions that will cause the execution of a task to end:</p>

<ul>
<li>Completing the task: the task has no more expressions to run.</li>
<li>Failing the task: an expression raised an error that was not handled</li>
<li>Canceling the task: this can be done through the <code>cancel</code> and <code>cancel_task</code> keywords.</li>
<li>Aborting the task: this can be done through the <code>abort</code> and <code>abort_task</code> keywords.</li>
</ul>

<h4 id="canceling-a-task-or-a-process">Canceling a task or a process</h4>

<p>Canceling a task can be done at any time in any task using the <code>cancel_task</code> keyword. This provides a way to finish <q>cleanly</q> a task that still has expressions to run. The cloud workflow can define rollback handlers that get triggered when the task cancels. These handlers behave much like timeout or error handlers: they may take arbitrary arguments and inherit the local variables and references of the caller. Nested rollback handlers are executed in reverse order as shown in this example:</p>
<pre class="syntax-highlight ruby"><code><span class="n">define</span> <span class="n">delete_deployment</span><span class="p">(</span><span class="vg">$deployment_name</span><span class="p">)</span> <span class="k">do</span>
  <span class="vi">@deployment</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name=="</span> <span class="o">+</span> <span class="vg">$deployment_name</span><span class="p">])</span>
  <span class="vi">@deployment</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
<span class="k">end</span>

<span class="n">define</span> <span class="n">delete_servers</span><span class="p">(</span><span class="vg">$server_names</span><span class="p">)</span> <span class="k">do</span>
  <span class="n">foreach</span> <span class="vg">$name</span> <span class="k">in</span> <span class="vg">$server_names</span> <span class="k">do</span>
    <span class="vi">@server</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name=="</span> <span class="o">+</span> <span class="vg">$name</span><span class="p">])</span>
    <span class="vi">@sever</span><span class="p">.</span><span class="nf">destroy</span><span class="p">()</span>
  <span class="k">end</span>
<span class="k">end</span>
<span class="nb">sub</span> <span class="ss">on_rollback: </span><span class="n">delete_deployment</span><span class="p">(</span><span class="vg">$deployment_name</span><span class="p">)</span> <span class="k">do</span>  <span class="c1"># Assumes $deployment_name exists</span>
  <span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">deployment: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="vg">$deployment_name</span> <span class="p">})</span>
  <span class="c1"># ... do more stuff</span>
  <span class="nb">sub</span> <span class="ss">on_rollback: </span><span class="n">delete_servers</span><span class="p">(</span><span class="vg">$server_names</span><span class="p">)</span> <span class="k">do</span>    <span class="c1"># Assumes $server_names exists</span>
    <span class="n">foreach</span> <span class="vg">$name</span> <span class="k">in</span> <span class="vg">$server_names</span> <span class="k">do</span>
      <span class="c1"># Assumes $server_params exists and is a hash of all required params to create a server</span>
      <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">server: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="vg">$name</span> <span class="p">}</span> <span class="o">+</span> <span class="vg">$server_params</span><span class="p">)</span>
      <span class="c1"># ... do more stuff</span>
    <span class="k">end</span>
    <span class="c1"># ... do more stuff, initialize $has_errors</span>
    <span class="k">if</span> <span class="vg">$has_errors</span>
      <span class="n">cancel_task</span> <span class="c1"># Will call both delete_servers and delete_deployment in this order</span>
    <span class="k">end</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In this snippet, if <code>$has_errors</code> gets initialized then the process is canceled and both the <code>delete_servers</code> and the <code>delete_deployment</code> get run in that order.</p>

<p>Canceling a process is done using the <code>cancel</code> keyword. This causes all the running tasks to be canceled and follow the same logic as above, potentially executing multiple rollback handlers concurrently. Once all rollback handlers finish then the process ends and the status of all its tasks is set to canceled.</p>

<h4 id="aborting-a-task-or-a-process">Aborting a task or a process</h4>

<p>Tasks can also be terminated through the <code>abort_task</code> keyword. This causes the task to finish immediately bypassing all rollback handlers. The <code>abort</code> keyword causes all the tasks in the current process to be aborted. The process thus finishes immediately and the status of all its tasks is set to aborted.</p>

<h3 id="processes-concurrency-and-expressions">Concurrency and Expressions</h3>

<p>As described in Cloud Workflow and Definitions a definition consists of a sequence of <em>statements</em>. Each <em>statement</em> is in turn made of <em>expressions</em>. The engine makes the following guarantee:</p>

<ul>
<li>Expressions always run atomatically</li>
</ul>

<p>In particular, if we consider any expression running in a concurrence (inside a <code>concurrent</code>, <code>concurrent foreach</code>, or <code>concurrent map</code>), then the rule above dictates that each concurrent expression runs atomatically. So if we consider:</p>
<pre class="syntax-highlight ruby"><code><span class="n">concurrent</span> <span class="k">do</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vi">@servers</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">servers</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="s2">"name==app_server"</span><span class="p">)</span>
    <span class="vc">@@instances</span> <span class="o">&lt;&lt;</span> <span class="vi">@servers</span><span class="p">.</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># (1)</span>
  <span class="k">end</span>
  <span class="nb">sub</span> <span class="k">do</span>
    <span class="vc">@@instances</span> <span class="o">&lt;&lt;</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/servers/123"</span><span class="p">).</span><span class="nf">launch</span><span class="p">()</span> <span class="c1"># (2)</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In the definition above, statement (1) is composed of two expressions: the call to the <code>launch()</code> action followed by the assignment to <code>@@instances</code>. Statement (2) is composed of 3 expressions: the call to <code>get()</code> followed by the call to <code>launch()</code> and finally the append to the <code>@@instances</code> collection. Since expressions run atomatically the definition above guarantees that the <code>@@instances</code> collection will end-up with all instances, there is no need to explicitly synchronize the appends to <code>@@instances</code>. There is no guarantee about ordering though so it could be that the single instance retrieved in statement 2 is first in the collection.</p>

<p>Note that the following could generate inconsistent results:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># DO NOT DO THIS</span>
<span class="vi">@instances</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"state==operational"</span><span class="p">]).</span><span class="nf">current_instance</span><span class="p">()</span>

<span class="vg">$$</span><span class="n">failed</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">concurrent</span> <span class="n">foreach</span> <span class="vi">@instance</span> <span class="k">in</span> <span class="vi">@instances</span> <span class="k">do</span>
  <span class="vi">@task</span> <span class="o">=</span> <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"sys:do_reconverge_list_disable"</span><span class="p">)</span>
  <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@task</span><span class="p">.</span><span class="nf">summary</span> <span class="o">=~</span> <span class="s2">"/^completed|^failed/"</span><span class="p">)</span>
  <span class="k">if</span> <span class="vi">@task</span><span class="p">.</span><span class="nf">summary</span> <span class="o">=~</span> <span class="s2">"/^failed"</span>
    <span class="vg">$$</span><span class="n">failed</span> <span class="o">=</span> <span class="vg">$$</span><span class="n">failed</span> <span class="o">+</span> <span class="mi">1</span> <span class="c1"># (1) Oops, $$failed can be overridden concurrently</span>
  <span class="k">end</span>
<span class="k">end</span>
</code></pre>

<p>In the example above, statement (1) is comprised of two expressions: the increment and the assignment. If two tasks were to increment concurrently after reading the same value then one of the increments would get lost (both tasks would write back the same value to <code>$$failed</code>). The <code>concurrent map</code> expression should be used instead to build results concurrently:</p>
<pre class="syntax-highlight ruby"><code><span class="c1"># DO THIS INSTEAD</span>
<span class="vi">@instances</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">href: </span><span class="s2">"/api/deployments/123"</span><span class="p">).</span><span class="nf">servers</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"state==operational"</span><span class="p">]).</span><span class="nf">current_instance</span><span class="p">()</span>

<span class="vg">$failed_ones</span> <span class="o">=</span> <span class="n">concurrent</span> <span class="n">map</span> <span class="vi">@instance</span> <span class="k">in</span> <span class="vi">@instances</span> <span class="k">return</span> <span class="vg">$failed_one</span> <span class="k">do</span>
  <span class="vi">@task</span> <span class="o">=</span> <span class="vi">@instance</span><span class="p">.</span><span class="nf">run_executable</span><span class="p">(</span><span class="ss">recipe_name: </span><span class="s2">"sys:do_reconverge_list_disable"</span><span class="p">)</span>
  <span class="n">sleep_until</span><span class="p">(</span><span class="vi">@task</span><span class="p">.</span><span class="nf">summary</span> <span class="o">=~</span> <span class="s2">"/^completed|^failed/"</span><span class="p">)</span>
  <span class="k">if</span> <span class="vi">@task</span><span class="p">.</span><span class="nf">summary</span> <span class="o">=~</span> <span class="s2">"/^failed"</span>
    <span class="vg">$failed_one</span> <span class="o">=</span> <span class="mi">1</span>  
  <span class="k">end</span> <span class="c1"># Do not return anything on success</span>
<span class="k">end</span>
<span class="vg">$failed</span> <span class="o">=</span> <span class="n">size</span><span class="p">(</span><span class="vg">$failed_ones</span><span class="p">)</span>
</code></pre>

<p>The <code>concurrent map</code> expression takes care of building the resulting array from the results returned by each concurrent execution. There is no problem of the task overriding values concurrently in this case.</p>

<h3 id="processes-summary">Summary</h3>

<p>A process may run one or more tasks concurrently at any time. RCL allows for describing how these tasks should be synchronized by providing both synchronization primitives and keywords for controlling tasks individually. A process ends once all its tasks end. A task ends when it completes (no more expression to execute), fails (an expression raises an error that is not handled), is canceled or is aborted. Canceling a task will cause any rollback handler to trigger and do additional processing before the task ends.</p>

<p><strong>Note:</strong> <em>The concept of tasks and definitions are completely disjoint and should not be confused: a definition always runs in the task that ran the <code>call</code> expression. In other words, simply using <code>call</code> does not create a new task.</em></p>

<h2 id="mapping-resources-to-the-rightscale-apis">Mapping Resources to the RightScale APIs</h2>

<p>The <a href="http://reference.rightscale.com/api1.5/index.html">RightScale CM API 1.5 reference documentation</a> lists all the available resource types in the <code>rs</code> namespace and corresponding media types. This section describes how to use that documentation to use the corresponding resources in a cloud workflow.</p>

<h3 id="mapping-resources-to-the-rightscale-apis-api-resource-actions">API Resource Actions</h3>

<p>Resource actions are listed in the corresponding media type document under the <strong>Actions</strong> section. The required arguments are described in the resource document itself. For example, the media type for the <code>Instances</code> resource is described in the corresponding document and the actions are:</p>

<p><a href="http://reference.rightscale.com/api1.5/media_types/MediaTypeInstance.html#actions">from CM API 1.5 Instance Media Type docs</a></p>

<h4 id="actions">Actions</h4>

<table><thead>
<tr>
<th>Action</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>run_executable</td>
<td>Runs a script or recipe on the instance</td>
</tr>
<tr>
<td>terminate</td>
<td>Terminates the instance</td>
</tr>
<tr>
<td>reboot</td>
<td>Reboots a running instance</td>
</tr>
<tr>
<td>launch</td>
<td>Launches this instance with the current configuration</td>
</tr>
</tbody></table>

<p>The details on how to call the actions are described in the instances resource document, taking the <code>launch()</code> action as example:</p>

<p><a href="http://reference.rightscale.com/api1.5/resources/ResourceInstances.html#launch">from CM API 1.5 Instance Resource docs</a></p>

<h4 id="launch">launch</h4>

<p>Launches an instance using the parameters that this instance has been configured with.</p>

<p><strong>Note:</strong> <em>This action can only be performed in <q>next</q> instances, and not on instances that are already running.</em></p>

<p><strong>URLs</strong></p>

<ul>
<li>POST /api/clouds/:cloud_id/instances/:id/launch</li>
<li>POST /api/servers/:server_id/launch</li>
<li>POST /api/server_arrays/:server_array_id/launch</li>
</ul>

<p><strong>HTTP response code</strong></p>

<ul>
<li>201 Created</li>
</ul>

<p><strong>Location</strong></p>

<ul>
<li>Href of the launched Instance</li>
</ul>

<p><strong>Required roles</strong></p>

<ul>
<li>actor</li>
</ul>

<p><strong>Parameters</strong></p>

<table><thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Type</th>
<th>Values</th>
<th>regexp</th>
<th>Blank?</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>inputs</td>
<td>no</td>
<td>Array</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>inputs[][name]</td>
<td>yes</td>
<td>String</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td>The input name.</td>
</tr>
<tr>
<td>inputs[][value]</td>
<td>yes</td>
<td>String</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td>The value of that input. Should be of the form <code>text:my_value</code> or <code>cred:MY_CRED</code>, etc.</td>
</tr>
</tbody></table>

<p>Note that the engine will automatically map the <strong>Location</strong> response header to a resource collection and will make that resource collection the return value of the action. The action takes a single parameter inputs which is an array of hashes. Each hash should contain two elements: <code>name</code> and <code>value</code>. So the <code>launch()</code> action can be called in RCL using:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@running</span> <span class="o">=</span> <span class="vi">@next_instance</span><span class="p">.</span><span class="nf">launch</span><span class="p">(</span><span class="ss">inputs: </span><span class="p">[{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"ADMIN_EMAIL"</span><span class="p">,</span> <span class="s2">"value"</span><span class="p">:</span> <span class="s2">"text:admin@rightscale.com"</span> <span class="p">},</span>
                                          <span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"PASSWORD"</span><span class="p">,</span>    <span class="s2">"value"</span><span class="p">:</span> <span class="s2">"cred:PASSWORD"</span> <span class="p">}])</span>
</code></pre>

<h3 id="mapping-resources-to-the-rightscale-apis-api-resource-fields">API Resource Fields</h3>

<p>Resource fields are listed in the corresponding media type document under the <strong>Attributes</strong> section. Look at the documentation for the media type of the instances resource:</p>

<p><a href="http://reference.rightscale.com/api1.5/media_types/MediaTypeInstance.html">from CM API 1.5 Instance Media Type docs</a></p>

<p><strong>Attributes</strong></p>

<ul>
<li>private_dns_names</li>
<li>updated_at</li>
<li>monitoring_server</li>
<li>actions</li>
<li>terminated_at</li>
<li>inputs</li>
<li>os_platform</li>
<li>inherited_sources</li>
<li>description</li>
<li>public_ip_addresses</li>
<li>links</li>
<li>monitoring_id</li>
<li>private_ip_addresses</li>
<li>user_data</li>
<li>name</li>
<li>public_dns_names</li>
<li>resource_uid</li>
<li>security_groups</li>
<li>state</li>
<li>created_at</li>
</ul>

<h3 id="mapping-resources-to-the-rightscale-apis-api-resource-links">API Resource Links</h3>

<p>Resources links are listed in the corresponding media type document under the <strong>Relationships</strong> section. Look at the documentation for the media type of the instances resource:</p>

<p><a href="http://reference.rightscale.com/api1.5/media_types/MediaTypeInstance.html">from CM API 1.5 Instance Media Type docs</a></p>

<p><strong>Relationships</strong></p>

<table><thead>
<tr>
<th>Name</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>parent</td>
<td>Parent Object (Server/ServerArray)</td>
</tr>
<tr>
<td>self</td>
<td>Href of itself</td>
</tr>
<tr>
<td>datacenter</td>
<td>Associated datacenter</td>
</tr>
<tr>
<td>multi_cloud_image</td>
<td>Associated multi cloud image</td>
</tr>
<tr>
<td>inputs</td>
<td>List of configuration inputs</td>
</tr>
<tr>
<td>server_template</td>
<td>Associated ServerTemplate</td>
</tr>
<tr>
<td>ramdisk_image</td>
<td>Associated ramdisk image</td>
</tr>
<tr>
<td>volume_attachments</td>
<td>Associated volume attachments</td>
</tr>
<tr>
<td>instance_type</td>
<td>Associated instance type</td>
</tr>
<tr>
<td>monitoring_metrics</td>
<td>Associated monitoring metrics</td>
</tr>
<tr>
<td>kernel_image</td>
<td>Associated kernel image</td>
</tr>
<tr>
<td>ssh_key</td>
<td>Associated ssh key</td>
</tr>
<tr>
<td>image</td>
<td>Associated image</td>
</tr>
<tr>
<td>deployment</td>
<td>Associated Deployment</td>
</tr>
<tr>
<td>cloud</td>
<td>Associated Cloud</td>
</tr>
</tbody></table>

<p>Note that some links yield individual resources while others yield a collection. In the example above <code>server_template()</code> returns a single resource while <code>volume_attachments()</code> returns a collection. The possible link parameters are given by the description of the show request of the link resource if the link is for a single resource. Otherwise, they are given by the description of the index request. In the example above, the <code>server_templates</code> resource <code>show</code> request described in the resource documentation lists one potential parameter view which can be used in RCL as follows:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@instance</span><span class="p">.</span><span class="nf">server_template</span><span class="p">(</span><span class="ss">view: </span><span class="s2">"default"</span><span class="p">)</span>
</code></pre>

<h3 id="mapping-resources-to-the-rightscale-apis-api-resource-type-actions">API Resource Type Actions</h3>

<h4 id="get()">get()</h4>

<p>The resource types <code>get()</code> action map to a index request on the corresponding resource. The parameters are thus described in the resources index request documentation. For example, for instances:</p>

<p><a href="http://reference.rightscale.com/api1.5/resources/ResourceInstances.html#index">from CM API 1.5 Instance Resource docs</a></p>

<p><strong>index</strong></p>

<p>Lists instances of a given cloud.</p>

<p>Using the available filters, it is possible to craft powerful queries about which instances to retrieve. For example, one can easily list:</p>

<ul>
<li>instances that have names that contain <q>app</q></li>
<li>all instances of a given deployment</li>
<li>instances belonging to a given server array (i.e., have the same parent_url)</li>
</ul>

<p><strong>URLs</strong></p>

<ul>
<li>GET /api/clouds/:cloud_id/instances</li>
<li>GET /api/server_arrays/:server_array_id/current_instances</li>
</ul>

<p><strong>HTTP response code</strong></p>

<ul>
<li>200 OK</li>
</ul>

<p><strong>Content-type</strong></p>

<ul>
<li>application/vnd.rightscale.instance;type=collection</li>
</ul>

<p><strong>Required roles</strong></p>

<ul>
<li>observer</li>
</ul>

<p><strong>Parameters</strong></p>

<table><thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Type</th>
<th>Values</th>
<th>regexp</th>
<th>Blank?</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>filter</td>
<td>no</td>
<td>Array</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td>See below for valid filter parameters.</td>
</tr>
<tr>
<td>view</td>
<td>no</td>
<td>String</td>
<td><code>default</code>, <code>extended</code>, <code>full</code></td>
<td>*</td>
<td>no</td>
<td>Specifies how many attributes and/or expanded nested relationships to include.</td>
</tr>
</tbody></table>

<p><strong>Filters</strong></p>

<table><thead>
<tr>
<th>Name</th>
<th>partial_match?</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>datacenter_href</td>
<td>no</td>
<td>The href of the datacenter to filter on.</td>
</tr>
<tr>
<td>deployment_href</td>
<td>no</td>
<td>The href of the deployment to filter on.</td>
</tr>
<tr>
<td>name</td>
<td>yes</td>
<td>Name of the Instance to filter on.</td>
</tr>
<tr>
<td>os_platform</td>
<td>yes</td>
<td>The OS platform to filter on.</td>
</tr>
<tr>
<td>parent_href</td>
<td>no</td>
<td>The href of the parent to filter on.</td>
</tr>
<tr>
<td>private_dns_name</td>
<td>yes</td>
<td>The private dns name to filter on.</td>
</tr>
<tr>
<td>private_ip_address</td>
<td>yes</td>
<td>The private ip address to filter on.</td>
</tr>
<tr>
<td>public_dns_name</td>
<td>yes</td>
<td>The public dns name to filter on.</td>
</tr>
<tr>
<td>public_ip_address</td>
<td>yes</td>
<td>The public ip address to filter on.</td>
</tr>
<tr>
<td>resource_uid</td>
<td>no</td>
<td>Resource Unique IDentifier for the Instance to filter on.</td>
</tr>
<tr>
<td>server_template_href</td>
<td>no</td>
<td>The href of the ServerTemplate to filter on.</td>
</tr>
<tr>
<td>state</td>
<td>no</td>
<td>The state of Instances to filter on.</td>
</tr>
</tbody></table>

<p>Filters are given in the filter parameter which corresponds to an array of filter expressions. A filter expression consists of a filter name (from the table above) and a comparison to a value using either <code>==</code> or <code>&lt;&gt;</code>. For example, to retrieve all instances in the account whose name is not master_db one could write:</p>
<pre class="syntax-highlight ruby"><code><span class="vi">@instances</span> <span class="o">=</span> <span class="n">rs</span><span class="p">.</span><span class="nf">instances</span><span class="p">.</span><span class="nf">get</span><span class="p">(</span><span class="ss">filter: </span><span class="p">[</span><span class="s2">"name &lt;&gt; master_db"</span><span class="p">])</span>
</code></pre>

<h4 id="create()-and-update()">create() and update()</h4>

<p>Possible parameters for the resource types <code>create()</code> and <code>update()</code> actions are described by the corresponding resource request documentation. Looking at the deployments resource as an example, the corresponding documentation for the create request is:</p>

<p><a href="http://reference.rightscale.com/api1.5/resources/ResourceDeployments.html#create">from CM API 1.5 Instance Resource docs</a></p>

<p><strong>create</strong></p>

<p>Creates a new deployment with the given parameters.</p>

<p><strong>URLs</strong></p>

<ul>
<li>POST /api/deployments</li>
</ul>

<p><strong>HTTP response code</strong></p>

<ul>
<li>201 Created</li>
</ul>

<p><strong>Location</strong></p>

<ul>
<li>Href of the created deployment</li>
</ul>

<p><strong>Required roles</strong></p>

<ul>
<li>actor</li>
</ul>

<p><strong>Required settings</strong></p>

<ul>
<li>premium_deployments</li>
</ul>

<p><strong>Parameters</strong></p>

<table><thead>
<tr>
<th>Name</th>
<th>Required</th>
<th>Type</th>
<th>Values</th>
<th>regexp</th>
<th>Blank?</th>
<th>Description</th>
</tr>
</thead><tbody>
<tr>
<td>deployment</td>
<td>yes</td>
<td>Hash</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td></td>
</tr>
<tr>
<td>deployment[description]</td>
<td>no</td>
<td>String</td>
<td>*</td>
<td>*</td>
<td>yes</td>
<td>The description of the deployment to be created.</td>
</tr>
<tr>
<td>deployment[name]</td>
<td>yes</td>
<td>String</td>
<td>*</td>
<td>*</td>
<td>no</td>
<td>The name of the deployment to be created.</td>
</tr>
<tr>
<td>deployment[ server_tag_scope ]</td>
<td>no</td>
<td>String</td>
<td><code>deployment</code>, <code>account</code></td>
<td>*</td>
<td>yes</td>
<td>The routing scope for tags for servers in the deployment.</td>
</tr>
</tbody></table>

<p>So a deployment <code>create()</code> action takes a single hash argument named <code>deployment</code> which consists of a hash with two keys: <code>name</code> and <code>description</code>. A deployment can thus be created in RCL using:</p>
<pre class="syntax-highlight ruby"><code><span class="n">rs</span><span class="p">.</span><span class="nf">deployments</span><span class="p">.</span><span class="nf">create</span><span class="p">(</span><span class="ss">deployment: </span><span class="p">{</span> <span class="s2">"name"</span><span class="p">:</span> <span class="s2">"LAMP Stack"</span><span class="p">,</span>
                                    <span class="s2">"description"</span><span class="p">:</span> <span class="s2">"Servers making up the LAMP Stack application"</span> <span class="p">})</span>
</code></pre>
</div></div></div><div class="col-sm-3 hidden-xs affix-parent"><div class="clearfix" data-clampedwidth=".affix-parent" data-offset-bottom="200" data-offset-top="4" data-spy="affix"><nav class="subnav-right" id="subnav-right" role="sub-nav"><script>createRightHandNav();</script></nav></div></div></div></div></div></div></div><footer class="main-footer" role="contentinfo"><div class="container-fluid max-width"><div class="row"><div class="col-sm-10"><ul class="list-inline"><li><small>&copy; 2024 Flexera</small></li><li><a href="http://www.flexera.com/" target="_blank"><small>Flexera Home</small></a></li><li><a href="https://www.flexera.com/about-us/careers.html" target="_blank"><small>We're Hiring</small></a></li></ul></div></div></div></footer><noscript><iframe height="0" src="//www.googletagmanager.com/ns.html?id=GTM-KB9SMN" style="display:none;visibility:hidden" width="0"></iframe></noscript><script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0], j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src= '//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f); })(window,document,'script','dataLayer','GTM-KB9SMN');</script><script type="text/javascript">
  // Add clipboard button trigger
  var snippets = document.querySelectorAll('.syntax-highlight');
  [].forEach.call(snippets, function(snippet) {
  snippet.firstChild.insertAdjacentHTML('beforebegin', '<button class="btn snippet-clipboard" data-clipboard-snippet><img src="/img/icon-clipboard.svg"></button>');
  });

  // clipboard trigger
  var clipboardSnippets = new Clipboard('[data-clipboard-snippet]', {
  target: function(trigger) {
  return trigger.nextElementSibling;
  }
  });

  // Tooltip trigger
  clipboardSnippets.on('success', function(e) {
  e.clearSelection();
  showTooltip(e.trigger, 'Copied!');
  });

  // Error message
  clipboardSnippets.on('error', function(e) {
  showTooltip(e.trigger, fallbackMessage(e.action));
  });

  // Tooltip events
  var btns = document.querySelectorAll('.syntax-highlight .btn');
  for (var i = 0; i < btns.length; i++) {
  btns[i].addEventListener('mouseleave', clearTooltip);
  btns[i].addEventListener('blur', clearTooltip);
  }

  function clearTooltip(e) {
  e.currentTarget.setAttribute('class', 'btn');
  e.currentTarget.removeAttribute('aria-label');
  }

  function showTooltip(elem, msg) {
  elem.setAttribute('class', 'btn tooltipped tooltipped-s');
  elem.setAttribute('aria-label', msg);
  }
</script></body></html>